// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Events/DiadocMessage.PostApi.proto

#ifndef PROTOBUF_Events_2fDiadocMessage_2ePostApi_2eproto__INCLUDED
#define PROTOBUF_Events_2fDiadocMessage_2ePostApi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "../DocumentId.pb.h"
#include "ResolutionInfo.pb.h"
#include "ResolutionRequestInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Events {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

class MessageToPost;
class XmlDocumentAttachment;
class NonformalizedAttachment;
class BasicDocumentAttachment;
class Torg13Attachment;
class AcceptanceCertificateAttachment;
class TrustConnectionRequestAttachment;
class StructuredDataAttachment;
class PriceListAttachment;
class ReconciliationActAttachment;
class ContractAttachment;
class ServiceDetailsAttachment;
class MessagePatchToPost;
class ResolutionRequestAttachment;
class ResolutionRequestCancellationAttachment;
class ResolutionRequestDenialCancellationAttachment;
class ResolutionRequestDenialAttachment;
class ResolutionAttachment;
class ReceiptAttachment;
class CorrectionRequestAttachment;
class DocumentSignature;
class RequestedSignatureRejection;
class SignedContent;
class DraftToSend;
class MessageToSend;
class RevocationRequestAttachment;
class XmlSignatureRejectionAttachment;

// ===================================================================

class MessageToPost : public ::google::protobuf::Message {
 public:
  MessageToPost();
  virtual ~MessageToPost();

  MessageToPost(const MessageToPost& from);

  inline MessageToPost& operator=(const MessageToPost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageToPost& default_instance();

  void Swap(MessageToPost* other);

  // implements Message ----------------------------------------------

  MessageToPost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageToPost& from);
  void MergeFrom(const MessageToPost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string FromBoxId = 1;
  inline bool has_fromboxid() const;
  inline void clear_fromboxid();
  static const int kFromBoxIdFieldNumber = 1;
  inline const ::std::string& fromboxid() const;
  inline void set_fromboxid(const ::std::string& value);
  inline void set_fromboxid(const char* value);
  inline void set_fromboxid(const char* value, size_t size);
  inline ::std::string* mutable_fromboxid();
  inline ::std::string* release_fromboxid();
  inline void set_allocated_fromboxid(::std::string* fromboxid);

  // optional string ToBoxId = 2;
  inline bool has_toboxid() const;
  inline void clear_toboxid();
  static const int kToBoxIdFieldNumber = 2;
  inline const ::std::string& toboxid() const;
  inline void set_toboxid(const ::std::string& value);
  inline void set_toboxid(const char* value);
  inline void set_toboxid(const char* value, size_t size);
  inline ::std::string* mutable_toboxid();
  inline ::std::string* release_toboxid();
  inline void set_allocated_toboxid(::std::string* toboxid);

  // repeated .Diadoc.Api.Proto.Events.XmlDocumentAttachment Invoices = 3;
  inline int invoices_size() const;
  inline void clear_invoices();
  static const int kInvoicesFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Events::XmlDocumentAttachment& invoices(int index) const;
  inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* mutable_invoices(int index);
  inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* add_invoices();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >&
      invoices() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >*
      mutable_invoices();

  // repeated .Diadoc.Api.Proto.Events.NonformalizedAttachment NonformalizedDocuments = 4;
  inline int nonformalizeddocuments_size() const;
  inline void clear_nonformalizeddocuments();
  static const int kNonformalizedDocumentsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Events::NonformalizedAttachment& nonformalizeddocuments(int index) const;
  inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* mutable_nonformalizeddocuments(int index);
  inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* add_nonformalizeddocuments();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >&
      nonformalizeddocuments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >*
      mutable_nonformalizeddocuments();

  // repeated .Diadoc.Api.Proto.Events.BasicDocumentAttachment Torg12Documents = 5;
  inline int torg12documents_size() const;
  inline void clear_torg12documents();
  static const int kTorg12DocumentsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Events::BasicDocumentAttachment& torg12documents(int index) const;
  inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* mutable_torg12documents(int index);
  inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* add_torg12documents();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >&
      torg12documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >*
      mutable_torg12documents();

  // optional .Diadoc.Api.Proto.Events.TrustConnectionRequestAttachment TrustConnectionRequest = 6;
  inline bool has_trustconnectionrequest() const;
  inline void clear_trustconnectionrequest();
  static const int kTrustConnectionRequestFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment& trustconnectionrequest() const;
  inline ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* mutable_trustconnectionrequest();
  inline ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* release_trustconnectionrequest();
  inline void set_allocated_trustconnectionrequest(::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* trustconnectionrequest);

  // repeated .Diadoc.Api.Proto.Events.AcceptanceCertificateAttachment AcceptanceCertificates = 7;
  inline int acceptancecertificates_size() const;
  inline void clear_acceptancecertificates();
  static const int kAcceptanceCertificatesFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment& acceptancecertificates(int index) const;
  inline ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment* mutable_acceptancecertificates(int index);
  inline ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment* add_acceptancecertificates();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment >&
      acceptancecertificates() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment >*
      mutable_acceptancecertificates();

  // repeated .Diadoc.Api.Proto.Events.StructuredDataAttachment StructuredDataAttachments = 8;
  inline int structureddataattachments_size() const;
  inline void clear_structureddataattachments();
  static const int kStructuredDataAttachmentsFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Events::StructuredDataAttachment& structureddataattachments(int index) const;
  inline ::Diadoc::Api::Proto::Events::StructuredDataAttachment* mutable_structureddataattachments(int index);
  inline ::Diadoc::Api::Proto::Events::StructuredDataAttachment* add_structureddataattachments();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::StructuredDataAttachment >&
      structureddataattachments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::StructuredDataAttachment >*
      mutable_structureddataattachments();

  // repeated .Diadoc.Api.Proto.Events.BasicDocumentAttachment ProformaInvoices = 9;
  inline int proformainvoices_size() const;
  inline void clear_proformainvoices();
  static const int kProformaInvoicesFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Events::BasicDocumentAttachment& proformainvoices(int index) const;
  inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* mutable_proformainvoices(int index);
  inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* add_proformainvoices();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >&
      proformainvoices() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >*
      mutable_proformainvoices();

  // repeated .Diadoc.Api.Proto.Events.XmlDocumentAttachment XmlTorg12SellerTitles = 10;
  inline int xmltorg12sellertitles_size() const;
  inline void clear_xmltorg12sellertitles();
  static const int kXmlTorg12SellerTitlesFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Events::XmlDocumentAttachment& xmltorg12sellertitles(int index) const;
  inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* mutable_xmltorg12sellertitles(int index);
  inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* add_xmltorg12sellertitles();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >&
      xmltorg12sellertitles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >*
      mutable_xmltorg12sellertitles();

  // repeated .Diadoc.Api.Proto.Events.XmlDocumentAttachment XmlAcceptanceCertificateSellerTitles = 11;
  inline int xmlacceptancecertificatesellertitles_size() const;
  inline void clear_xmlacceptancecertificatesellertitles();
  static const int kXmlAcceptanceCertificateSellerTitlesFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Events::XmlDocumentAttachment& xmlacceptancecertificatesellertitles(int index) const;
  inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* mutable_xmlacceptancecertificatesellertitles(int index);
  inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* add_xmlacceptancecertificatesellertitles();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >&
      xmlacceptancecertificatesellertitles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >*
      mutable_xmlacceptancecertificatesellertitles();

  // optional string ToDepartmentId = 12;
  inline bool has_todepartmentid() const;
  inline void clear_todepartmentid();
  static const int kToDepartmentIdFieldNumber = 12;
  inline const ::std::string& todepartmentid() const;
  inline void set_todepartmentid(const ::std::string& value);
  inline void set_todepartmentid(const char* value);
  inline void set_todepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_todepartmentid();
  inline ::std::string* release_todepartmentid();
  inline void set_allocated_todepartmentid(::std::string* todepartmentid);

  // optional bool IsDraft = 13 [default = false];
  inline bool has_isdraft() const;
  inline void clear_isdraft();
  static const int kIsDraftFieldNumber = 13;
  inline bool isdraft() const;
  inline void set_isdraft(bool value);

  // optional bool LockDraft = 14 [default = false];
  inline bool has_lockdraft() const;
  inline void clear_lockdraft();
  static const int kLockDraftFieldNumber = 14;
  inline bool lockdraft() const;
  inline void set_lockdraft(bool value);

  // optional bool StrictDraftValidation = 15 [default = true];
  inline bool has_strictdraftvalidation() const;
  inline void clear_strictdraftvalidation();
  static const int kStrictDraftValidationFieldNumber = 15;
  inline bool strictdraftvalidation() const;
  inline void set_strictdraftvalidation(bool value);

  // optional bool IsInternal = 16 [default = false];
  inline bool has_isinternal() const;
  inline void clear_isinternal();
  static const int kIsInternalFieldNumber = 16;
  inline bool isinternal() const;
  inline void set_isinternal(bool value);

  // optional string FromDepartmentId = 17;
  inline bool has_fromdepartmentid() const;
  inline void clear_fromdepartmentid();
  static const int kFromDepartmentIdFieldNumber = 17;
  inline const ::std::string& fromdepartmentid() const;
  inline void set_fromdepartmentid(const ::std::string& value);
  inline void set_fromdepartmentid(const char* value);
  inline void set_fromdepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_fromdepartmentid();
  inline ::std::string* release_fromdepartmentid();
  inline void set_allocated_fromdepartmentid(::std::string* fromdepartmentid);

  // optional bool DelaySend = 18 [default = false];
  inline bool has_delaysend() const;
  inline void clear_delaysend();
  static const int kDelaySendFieldNumber = 18;
  inline bool delaysend() const;
  inline void set_delaysend(bool value);

  // repeated .Diadoc.Api.Proto.Events.PriceListAttachment PriceLists = 19;
  inline int pricelists_size() const;
  inline void clear_pricelists();
  static const int kPriceListsFieldNumber = 19;
  inline const ::Diadoc::Api::Proto::Events::PriceListAttachment& pricelists(int index) const;
  inline ::Diadoc::Api::Proto::Events::PriceListAttachment* mutable_pricelists(int index);
  inline ::Diadoc::Api::Proto::Events::PriceListAttachment* add_pricelists();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::PriceListAttachment >&
      pricelists() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::PriceListAttachment >*
      mutable_pricelists();

  // repeated .Diadoc.Api.Proto.Events.NonformalizedAttachment PriceListAgreements = 20;
  inline int pricelistagreements_size() const;
  inline void clear_pricelistagreements();
  static const int kPriceListAgreementsFieldNumber = 20;
  inline const ::Diadoc::Api::Proto::Events::NonformalizedAttachment& pricelistagreements(int index) const;
  inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* mutable_pricelistagreements(int index);
  inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* add_pricelistagreements();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >&
      pricelistagreements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >*
      mutable_pricelistagreements();

  // repeated .Diadoc.Api.Proto.Events.NonformalizedAttachment CertificateRegistries = 21;
  inline int certificateregistries_size() const;
  inline void clear_certificateregistries();
  static const int kCertificateRegistriesFieldNumber = 21;
  inline const ::Diadoc::Api::Proto::Events::NonformalizedAttachment& certificateregistries(int index) const;
  inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* mutable_certificateregistries(int index);
  inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* add_certificateregistries();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >&
      certificateregistries() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >*
      mutable_certificateregistries();

  // repeated .Diadoc.Api.Proto.Events.ReconciliationActAttachment ReconciliationActs = 22;
  inline int reconciliationacts_size() const;
  inline void clear_reconciliationacts();
  static const int kReconciliationActsFieldNumber = 22;
  inline const ::Diadoc::Api::Proto::Events::ReconciliationActAttachment& reconciliationacts(int index) const;
  inline ::Diadoc::Api::Proto::Events::ReconciliationActAttachment* mutable_reconciliationacts(int index);
  inline ::Diadoc::Api::Proto::Events::ReconciliationActAttachment* add_reconciliationacts();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReconciliationActAttachment >&
      reconciliationacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReconciliationActAttachment >*
      mutable_reconciliationacts();

  // repeated .Diadoc.Api.Proto.Events.ContractAttachment Contracts = 23;
  inline int contracts_size() const;
  inline void clear_contracts();
  static const int kContractsFieldNumber = 23;
  inline const ::Diadoc::Api::Proto::Events::ContractAttachment& contracts(int index) const;
  inline ::Diadoc::Api::Proto::Events::ContractAttachment* mutable_contracts(int index);
  inline ::Diadoc::Api::Proto::Events::ContractAttachment* add_contracts();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ContractAttachment >&
      contracts() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ContractAttachment >*
      mutable_contracts();

  // repeated .Diadoc.Api.Proto.Events.Torg13Attachment Torg13Documents = 24;
  inline int torg13documents_size() const;
  inline void clear_torg13documents();
  static const int kTorg13DocumentsFieldNumber = 24;
  inline const ::Diadoc::Api::Proto::Events::Torg13Attachment& torg13documents(int index) const;
  inline ::Diadoc::Api::Proto::Events::Torg13Attachment* mutable_torg13documents(int index);
  inline ::Diadoc::Api::Proto::Events::Torg13Attachment* add_torg13documents();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Torg13Attachment >&
      torg13documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Torg13Attachment >*
      mutable_torg13documents();

  // repeated .Diadoc.Api.Proto.Events.ServiceDetailsAttachment ServiceDetailsDocuments = 25;
  inline int servicedetailsdocuments_size() const;
  inline void clear_servicedetailsdocuments();
  static const int kServiceDetailsDocumentsFieldNumber = 25;
  inline const ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment& servicedetailsdocuments(int index) const;
  inline ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment* mutable_servicedetailsdocuments(int index);
  inline ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment* add_servicedetailsdocuments();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment >&
      servicedetailsdocuments() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment >*
      mutable_servicedetailsdocuments();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.MessageToPost)
 private:
  inline void set_has_fromboxid();
  inline void clear_has_fromboxid();
  inline void set_has_toboxid();
  inline void clear_has_toboxid();
  inline void set_has_trustconnectionrequest();
  inline void clear_has_trustconnectionrequest();
  inline void set_has_todepartmentid();
  inline void clear_has_todepartmentid();
  inline void set_has_isdraft();
  inline void clear_has_isdraft();
  inline void set_has_lockdraft();
  inline void clear_has_lockdraft();
  inline void set_has_strictdraftvalidation();
  inline void clear_has_strictdraftvalidation();
  inline void set_has_isinternal();
  inline void clear_has_isinternal();
  inline void set_has_fromdepartmentid();
  inline void clear_has_fromdepartmentid();
  inline void set_has_delaysend();
  inline void clear_has_delaysend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fromboxid_;
  ::std::string* toboxid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment > invoices_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment > nonformalizeddocuments_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment > torg12documents_;
  ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* trustconnectionrequest_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment > acceptancecertificates_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::StructuredDataAttachment > structureddataattachments_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment > proformainvoices_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment > xmltorg12sellertitles_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment > xmlacceptancecertificatesellertitles_;
  ::std::string* todepartmentid_;
  bool isdraft_;
  bool lockdraft_;
  bool strictdraftvalidation_;
  bool isinternal_;
  bool delaysend_;
  ::std::string* fromdepartmentid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::PriceListAttachment > pricelists_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment > pricelistagreements_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment > certificateregistries_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReconciliationActAttachment > reconciliationacts_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ContractAttachment > contracts_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Torg13Attachment > torg13documents_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment > servicedetailsdocuments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static MessageToPost* default_instance_;
};
// -------------------------------------------------------------------

class XmlDocumentAttachment : public ::google::protobuf::Message {
 public:
  XmlDocumentAttachment();
  virtual ~XmlDocumentAttachment();

  XmlDocumentAttachment(const XmlDocumentAttachment& from);

  inline XmlDocumentAttachment& operator=(const XmlDocumentAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XmlDocumentAttachment& default_instance();

  void Swap(XmlDocumentAttachment* other);

  // implements Message ----------------------------------------------

  XmlDocumentAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XmlDocumentAttachment& from);
  void MergeFrom(const XmlDocumentAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional bool NeedReceipt = 7 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 7;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.XmlDocumentAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static XmlDocumentAttachment* default_instance_;
};
// -------------------------------------------------------------------

class NonformalizedAttachment : public ::google::protobuf::Message {
 public:
  NonformalizedAttachment();
  virtual ~NonformalizedAttachment();

  NonformalizedAttachment(const NonformalizedAttachment& from);

  inline NonformalizedAttachment& operator=(const NonformalizedAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NonformalizedAttachment& default_instance();

  void Swap(NonformalizedAttachment* other);

  // implements Message ----------------------------------------------

  NonformalizedAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NonformalizedAttachment& from);
  void MergeFrom(const NonformalizedAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional bool NeedRecipientSignature = 4 [default = false];
  inline bool has_needrecipientsignature() const;
  inline void clear_needrecipientsignature();
  static const int kNeedRecipientSignatureFieldNumber = 4;
  inline bool needrecipientsignature() const;
  inline void set_needrecipientsignature(bool value);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 5;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 6;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional bool NeedReceipt = 10 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 10;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.NonformalizedAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_needrecipientsignature();
  inline void clear_has_needrecipientsignature();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* customdocumentid_;
  bool needrecipientsignature_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static NonformalizedAttachment* default_instance_;
};
// -------------------------------------------------------------------

class BasicDocumentAttachment : public ::google::protobuf::Message {
 public:
  BasicDocumentAttachment();
  virtual ~BasicDocumentAttachment();

  BasicDocumentAttachment(const BasicDocumentAttachment& from);

  inline BasicDocumentAttachment& operator=(const BasicDocumentAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicDocumentAttachment& default_instance();

  void Swap(BasicDocumentAttachment* other);

  // implements Message ----------------------------------------------

  BasicDocumentAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasicDocumentAttachment& from);
  void MergeFrom(const BasicDocumentAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // required string DocumentDate = 6;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 6;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 7;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 7;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required string Total = 8;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 8;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional string Vat = 10;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 10;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // optional string Grounds = 11;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 11;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // optional bool NeedReceipt = 12 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 12;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.BasicDocumentAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* total_;
  ::std::string* customdocumentid_;
  ::std::string* vat_;
  ::std::string* grounds_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static BasicDocumentAttachment* default_instance_;
};
// -------------------------------------------------------------------

class Torg13Attachment : public ::google::protobuf::Message {
 public:
  Torg13Attachment();
  virtual ~Torg13Attachment();

  Torg13Attachment(const Torg13Attachment& from);

  inline Torg13Attachment& operator=(const Torg13Attachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Torg13Attachment& default_instance();

  void Swap(Torg13Attachment* other);

  // implements Message ----------------------------------------------

  Torg13Attachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Torg13Attachment& from);
  void MergeFrom(const Torg13Attachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // required string DocumentDate = 6;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 6;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 7;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 7;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required string Total = 8;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 8;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional string Grounds = 11;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 11;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // optional bool NeedReceipt = 12 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 12;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.Torg13Attachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* total_;
  ::std::string* customdocumentid_;
  ::std::string* grounds_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static Torg13Attachment* default_instance_;
};
// -------------------------------------------------------------------

class AcceptanceCertificateAttachment : public ::google::protobuf::Message {
 public:
  AcceptanceCertificateAttachment();
  virtual ~AcceptanceCertificateAttachment();

  AcceptanceCertificateAttachment(const AcceptanceCertificateAttachment& from);

  inline AcceptanceCertificateAttachment& operator=(const AcceptanceCertificateAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptanceCertificateAttachment& default_instance();

  void Swap(AcceptanceCertificateAttachment* other);

  // implements Message ----------------------------------------------

  AcceptanceCertificateAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcceptanceCertificateAttachment& from);
  void MergeFrom(const AcceptanceCertificateAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // required string DocumentDate = 6;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 6;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 7;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 7;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required string Total = 8;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 8;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional string Vat = 10;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 10;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // optional string Grounds = 11;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 11;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // optional bool NeedReceipt = 12 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 12;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // optional bool NeedRecipientSignature = 13 [default = true];
  inline bool has_needrecipientsignature() const;
  inline void clear_needrecipientsignature();
  static const int kNeedRecipientSignatureFieldNumber = 13;
  inline bool needrecipientsignature() const;
  inline void set_needrecipientsignature(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.AcceptanceCertificateAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();
  inline void set_has_needrecipientsignature();
  inline void clear_has_needrecipientsignature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* total_;
  ::std::string* customdocumentid_;
  ::std::string* vat_;
  ::std::string* grounds_;
  bool needreceipt_;
  bool needrecipientsignature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static AcceptanceCertificateAttachment* default_instance_;
};
// -------------------------------------------------------------------

class TrustConnectionRequestAttachment : public ::google::protobuf::Message {
 public:
  TrustConnectionRequestAttachment();
  virtual ~TrustConnectionRequestAttachment();

  TrustConnectionRequestAttachment(const TrustConnectionRequestAttachment& from);

  inline TrustConnectionRequestAttachment& operator=(const TrustConnectionRequestAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrustConnectionRequestAttachment& default_instance();

  void Swap(TrustConnectionRequestAttachment* other);

  // implements Message ----------------------------------------------

  TrustConnectionRequestAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrustConnectionRequestAttachment& from);
  void MergeFrom(const TrustConnectionRequestAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional string CustomDocumentId = 4;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 4;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.TrustConnectionRequestAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::std::string* customdocumentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static TrustConnectionRequestAttachment* default_instance_;
};
// -------------------------------------------------------------------

class StructuredDataAttachment : public ::google::protobuf::Message {
 public:
  StructuredDataAttachment();
  virtual ~StructuredDataAttachment();

  StructuredDataAttachment(const StructuredDataAttachment& from);

  inline StructuredDataAttachment& operator=(const StructuredDataAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StructuredDataAttachment& default_instance();

  void Swap(StructuredDataAttachment* other);

  // implements Message ----------------------------------------------

  StructuredDataAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StructuredDataAttachment& from);
  void MergeFrom(const StructuredDataAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes Content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required string ParentCustomDocumentId = 3;
  inline bool has_parentcustomdocumentid() const;
  inline void clear_parentcustomdocumentid();
  static const int kParentCustomDocumentIdFieldNumber = 3;
  inline const ::std::string& parentcustomdocumentid() const;
  inline void set_parentcustomdocumentid(const ::std::string& value);
  inline void set_parentcustomdocumentid(const char* value);
  inline void set_parentcustomdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_parentcustomdocumentid();
  inline ::std::string* release_parentcustomdocumentid();
  inline void set_allocated_parentcustomdocumentid(::std::string* parentcustomdocumentid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.StructuredDataAttachment)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_parentcustomdocumentid();
  inline void clear_has_parentcustomdocumentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::std::string* filename_;
  ::std::string* parentcustomdocumentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static StructuredDataAttachment* default_instance_;
};
// -------------------------------------------------------------------

class PriceListAttachment : public ::google::protobuf::Message {
 public:
  PriceListAttachment();
  virtual ~PriceListAttachment();

  PriceListAttachment(const PriceListAttachment& from);

  inline PriceListAttachment& operator=(const PriceListAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceListAttachment& default_instance();

  void Swap(PriceListAttachment* other);

  // implements Message ----------------------------------------------

  PriceListAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceListAttachment& from);
  void MergeFrom(const PriceListAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // required string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required string PriceListEffectiveDate = 9;
  inline bool has_pricelisteffectivedate() const;
  inline void clear_pricelisteffectivedate();
  static const int kPriceListEffectiveDateFieldNumber = 9;
  inline const ::std::string& pricelisteffectivedate() const;
  inline void set_pricelisteffectivedate(const ::std::string& value);
  inline void set_pricelisteffectivedate(const char* value);
  inline void set_pricelisteffectivedate(const char* value, size_t size);
  inline ::std::string* mutable_pricelisteffectivedate();
  inline ::std::string* release_pricelisteffectivedate();
  inline void set_allocated_pricelisteffectivedate(::std::string* pricelisteffectivedate);

  // required string ContractDocumentDate = 10;
  inline bool has_contractdocumentdate() const;
  inline void clear_contractdocumentdate();
  static const int kContractDocumentDateFieldNumber = 10;
  inline const ::std::string& contractdocumentdate() const;
  inline void set_contractdocumentdate(const ::std::string& value);
  inline void set_contractdocumentdate(const char* value);
  inline void set_contractdocumentdate(const char* value, size_t size);
  inline ::std::string* mutable_contractdocumentdate();
  inline ::std::string* release_contractdocumentdate();
  inline void set_allocated_contractdocumentdate(::std::string* contractdocumentdate);

  // required string ContractDocumentNumber = 11;
  inline bool has_contractdocumentnumber() const;
  inline void clear_contractdocumentnumber();
  static const int kContractDocumentNumberFieldNumber = 11;
  inline const ::std::string& contractdocumentnumber() const;
  inline void set_contractdocumentnumber(const ::std::string& value);
  inline void set_contractdocumentnumber(const char* value);
  inline void set_contractdocumentnumber(const char* value, size_t size);
  inline ::std::string* mutable_contractdocumentnumber();
  inline ::std::string* release_contractdocumentnumber();
  inline void set_allocated_contractdocumentnumber(::std::string* contractdocumentnumber);

  // optional bool NeedReceipt = 12 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 12;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.PriceListAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_pricelisteffectivedate();
  inline void clear_has_pricelisteffectivedate();
  inline void set_has_contractdocumentdate();
  inline void clear_has_contractdocumentdate();
  inline void set_has_contractdocumentnumber();
  inline void clear_has_contractdocumentnumber();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* pricelisteffectivedate_;
  ::std::string* contractdocumentdate_;
  ::std::string* contractdocumentnumber_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static PriceListAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ReconciliationActAttachment : public ::google::protobuf::Message {
 public:
  ReconciliationActAttachment();
  virtual ~ReconciliationActAttachment();

  ReconciliationActAttachment(const ReconciliationActAttachment& from);

  inline ReconciliationActAttachment& operator=(const ReconciliationActAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconciliationActAttachment& default_instance();

  void Swap(ReconciliationActAttachment* other);

  // implements Message ----------------------------------------------

  ReconciliationActAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconciliationActAttachment& from);
  void MergeFrom(const ReconciliationActAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 5;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 6;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // required string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional bool NeedReceipt = 10 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 10;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ReconciliationActAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* customdocumentid_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ReconciliationActAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ContractAttachment : public ::google::protobuf::Message {
 public:
  ContractAttachment();
  virtual ~ContractAttachment();

  ContractAttachment(const ContractAttachment& from);

  inline ContractAttachment& operator=(const ContractAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContractAttachment& default_instance();

  void Swap(ContractAttachment* other);

  // implements Message ----------------------------------------------

  ContractAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContractAttachment& from);
  void MergeFrom(const ContractAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // required string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string ContractPrice = 9;
  inline bool has_contractprice() const;
  inline void clear_contractprice();
  static const int kContractPriceFieldNumber = 9;
  inline const ::std::string& contractprice() const;
  inline void set_contractprice(const ::std::string& value);
  inline void set_contractprice(const char* value);
  inline void set_contractprice(const char* value, size_t size);
  inline ::std::string* mutable_contractprice();
  inline ::std::string* release_contractprice();
  inline void set_allocated_contractprice(::std::string* contractprice);

  // optional string ContractType = 10;
  inline bool has_contracttype() const;
  inline void clear_contracttype();
  static const int kContractTypeFieldNumber = 10;
  inline const ::std::string& contracttype() const;
  inline void set_contracttype(const ::std::string& value);
  inline void set_contracttype(const char* value);
  inline void set_contracttype(const char* value, size_t size);
  inline ::std::string* mutable_contracttype();
  inline ::std::string* release_contracttype();
  inline void set_allocated_contracttype(::std::string* contracttype);

  // optional bool NeedReceipt = 11 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 11;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ContractAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_contractprice();
  inline void clear_has_contractprice();
  inline void set_has_contracttype();
  inline void clear_has_contracttype();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* contractprice_;
  ::std::string* contracttype_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ContractAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ServiceDetailsAttachment : public ::google::protobuf::Message {
 public:
  ServiceDetailsAttachment();
  virtual ~ServiceDetailsAttachment();

  ServiceDetailsAttachment(const ServiceDetailsAttachment& from);

  inline ServiceDetailsAttachment& operator=(const ServiceDetailsAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceDetailsAttachment& default_instance();

  void Swap(ServiceDetailsAttachment* other);

  // implements Message ----------------------------------------------

  ServiceDetailsAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceDetailsAttachment& from);
  void MergeFrom(const ServiceDetailsAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 5;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::DocumentId& initialdocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_initialdocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_initialdocumentids();

  // repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 6;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::DocumentId& subordinatedocumentids(int index) const;
  inline ::Diadoc::Api::Proto::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::Diadoc::Api::Proto::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional bool NeedReceipt = 10 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 10;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ServiceDetailsAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* customdocumentid_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ServiceDetailsAttachment* default_instance_;
};
// -------------------------------------------------------------------

class MessagePatchToPost : public ::google::protobuf::Message {
 public:
  MessagePatchToPost();
  virtual ~MessagePatchToPost();

  MessagePatchToPost(const MessagePatchToPost& from);

  inline MessagePatchToPost& operator=(const MessagePatchToPost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessagePatchToPost& default_instance();

  void Swap(MessagePatchToPost* other);

  // implements Message ----------------------------------------------

  MessagePatchToPost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessagePatchToPost& from);
  void MergeFrom(const MessagePatchToPost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string BoxId = 1;
  inline bool has_boxid() const;
  inline void clear_boxid();
  static const int kBoxIdFieldNumber = 1;
  inline const ::std::string& boxid() const;
  inline void set_boxid(const ::std::string& value);
  inline void set_boxid(const char* value);
  inline void set_boxid(const char* value, size_t size);
  inline ::std::string* mutable_boxid();
  inline ::std::string* release_boxid();
  inline void set_allocated_boxid(::std::string* boxid);

  // required string MessageId = 2;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 2;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  inline void set_allocated_messageid(::std::string* messageid);

  // repeated .Diadoc.Api.Proto.Events.ReceiptAttachment Receipts = 3;
  inline int receipts_size() const;
  inline void clear_receipts();
  static const int kReceiptsFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Events::ReceiptAttachment& receipts(int index) const;
  inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* mutable_receipts(int index);
  inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* add_receipts();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >&
      receipts() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >*
      mutable_receipts();

  // repeated .Diadoc.Api.Proto.Events.CorrectionRequestAttachment CorrectionRequests = 4;
  inline int correctionrequests_size() const;
  inline void clear_correctionrequests();
  static const int kCorrectionRequestsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment& correctionrequests(int index) const;
  inline ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment* mutable_correctionrequests(int index);
  inline ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment* add_correctionrequests();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment >&
      correctionrequests() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment >*
      mutable_correctionrequests();

  // repeated .Diadoc.Api.Proto.Events.DocumentSignature RequestedSignatures = 5;
  inline int requestedsignatures_size() const;
  inline void clear_requestedsignatures();
  static const int kRequestedSignaturesFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Events::DocumentSignature& requestedsignatures(int index) const;
  inline ::Diadoc::Api::Proto::Events::DocumentSignature* mutable_requestedsignatures(int index);
  inline ::Diadoc::Api::Proto::Events::DocumentSignature* add_requestedsignatures();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >&
      requestedsignatures() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >*
      mutable_requestedsignatures();

  // repeated .Diadoc.Api.Proto.Events.RequestedSignatureRejection RequestedSignatureRejections = 6;
  inline int requestedsignaturerejections_size() const;
  inline void clear_requestedsignaturerejections();
  static const int kRequestedSignatureRejectionsFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Events::RequestedSignatureRejection& requestedsignaturerejections(int index) const;
  inline ::Diadoc::Api::Proto::Events::RequestedSignatureRejection* mutable_requestedsignaturerejections(int index);
  inline ::Diadoc::Api::Proto::Events::RequestedSignatureRejection* add_requestedsignaturerejections();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RequestedSignatureRejection >&
      requestedsignaturerejections() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RequestedSignatureRejection >*
      mutable_requestedsignaturerejections();

  // repeated .Diadoc.Api.Proto.Events.ReceiptAttachment XmlTorg12BuyerTitles = 7;
  inline int xmltorg12buyertitles_size() const;
  inline void clear_xmltorg12buyertitles();
  static const int kXmlTorg12BuyerTitlesFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Events::ReceiptAttachment& xmltorg12buyertitles(int index) const;
  inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* mutable_xmltorg12buyertitles(int index);
  inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* add_xmltorg12buyertitles();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >&
      xmltorg12buyertitles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >*
      mutable_xmltorg12buyertitles();

  // repeated .Diadoc.Api.Proto.Events.ReceiptAttachment XmlAcceptanceCertificateBuyerTitles = 8;
  inline int xmlacceptancecertificatebuyertitles_size() const;
  inline void clear_xmlacceptancecertificatebuyertitles();
  static const int kXmlAcceptanceCertificateBuyerTitlesFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Events::ReceiptAttachment& xmlacceptancecertificatebuyertitles(int index) const;
  inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* mutable_xmlacceptancecertificatebuyertitles(int index);
  inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* add_xmlacceptancecertificatebuyertitles();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >&
      xmlacceptancecertificatebuyertitles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >*
      mutable_xmlacceptancecertificatebuyertitles();

  // repeated .Diadoc.Api.Proto.Events.ResolutionAttachment Resolutions = 9;
  inline int resolutions_size() const;
  inline void clear_resolutions();
  static const int kResolutionsFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Events::ResolutionAttachment& resolutions(int index) const;
  inline ::Diadoc::Api::Proto::Events::ResolutionAttachment* mutable_resolutions(int index);
  inline ::Diadoc::Api::Proto::Events::ResolutionAttachment* add_resolutions();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionAttachment >&
      resolutions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionAttachment >*
      mutable_resolutions();

  // repeated .Diadoc.Api.Proto.Events.ResolutionRequestAttachment ResolutionRequests = 10;
  inline int resolutionrequests_size() const;
  inline void clear_resolutionrequests();
  static const int kResolutionRequestsFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment& resolutionrequests(int index) const;
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment* mutable_resolutionrequests(int index);
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment* add_resolutionrequests();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment >&
      resolutionrequests() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment >*
      mutable_resolutionrequests();

  // repeated .Diadoc.Api.Proto.Events.ResolutionRequestCancellationAttachment ResolutionRequestCancellations = 11;
  inline int resolutionrequestcancellations_size() const;
  inline void clear_resolutionrequestcancellations();
  static const int kResolutionRequestCancellationsFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment& resolutionrequestcancellations(int index) const;
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment* mutable_resolutionrequestcancellations(int index);
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment* add_resolutionrequestcancellations();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment >&
      resolutionrequestcancellations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment >*
      mutable_resolutionrequestcancellations();

  // repeated .Diadoc.Api.Proto.Events.ResolutionRequestDenialAttachment ResolutionRequestDenials = 12;
  inline int resolutionrequestdenials_size() const;
  inline void clear_resolutionrequestdenials();
  static const int kResolutionRequestDenialsFieldNumber = 12;
  inline const ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment& resolutionrequestdenials(int index) const;
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment* mutable_resolutionrequestdenials(int index);
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment* add_resolutionrequestdenials();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment >&
      resolutionrequestdenials() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment >*
      mutable_resolutionrequestdenials();

  // repeated .Diadoc.Api.Proto.Events.ResolutionRequestDenialCancellationAttachment ResolutionRequestDenialCancellations = 13;
  inline int resolutionrequestdenialcancellations_size() const;
  inline void clear_resolutionrequestdenialcancellations();
  static const int kResolutionRequestDenialCancellationsFieldNumber = 13;
  inline const ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment& resolutionrequestdenialcancellations(int index) const;
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment* mutable_resolutionrequestdenialcancellations(int index);
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment* add_resolutionrequestdenialcancellations();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment >&
      resolutionrequestdenialcancellations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment >*
      mutable_resolutionrequestdenialcancellations();

  // repeated .Diadoc.Api.Proto.Events.RevocationRequestAttachment RevocationRequests = 14;
  inline int revocationrequests_size() const;
  inline void clear_revocationrequests();
  static const int kRevocationRequestsFieldNumber = 14;
  inline const ::Diadoc::Api::Proto::Events::RevocationRequestAttachment& revocationrequests(int index) const;
  inline ::Diadoc::Api::Proto::Events::RevocationRequestAttachment* mutable_revocationrequests(int index);
  inline ::Diadoc::Api::Proto::Events::RevocationRequestAttachment* add_revocationrequests();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RevocationRequestAttachment >&
      revocationrequests() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RevocationRequestAttachment >*
      mutable_revocationrequests();

  // repeated .Diadoc.Api.Proto.Events.XmlSignatureRejectionAttachment XmlSignatureRejections = 15;
  inline int xmlsignaturerejections_size() const;
  inline void clear_xmlsignaturerejections();
  static const int kXmlSignatureRejectionsFieldNumber = 15;
  inline const ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment& xmlsignaturerejections(int index) const;
  inline ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment* mutable_xmlsignaturerejections(int index);
  inline ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment* add_xmlsignaturerejections();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment >&
      xmlsignaturerejections() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment >*
      mutable_xmlsignaturerejections();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.MessagePatchToPost)
 private:
  inline void set_has_boxid();
  inline void clear_has_boxid();
  inline void set_has_messageid();
  inline void clear_has_messageid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* boxid_;
  ::std::string* messageid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment > receipts_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment > correctionrequests_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature > requestedsignatures_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RequestedSignatureRejection > requestedsignaturerejections_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment > xmltorg12buyertitles_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment > xmlacceptancecertificatebuyertitles_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionAttachment > resolutions_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment > resolutionrequests_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment > resolutionrequestcancellations_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment > resolutionrequestdenials_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment > resolutionrequestdenialcancellations_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RevocationRequestAttachment > revocationrequests_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment > xmlsignaturerejections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static MessagePatchToPost* default_instance_;
};
// -------------------------------------------------------------------

class ResolutionRequestAttachment : public ::google::protobuf::Message {
 public:
  ResolutionRequestAttachment();
  virtual ~ResolutionRequestAttachment();

  ResolutionRequestAttachment(const ResolutionRequestAttachment& from);

  inline ResolutionRequestAttachment& operator=(const ResolutionRequestAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolutionRequestAttachment& default_instance();

  void Swap(ResolutionRequestAttachment* other);

  // implements Message ----------------------------------------------

  ResolutionRequestAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolutionRequestAttachment& from);
  void MergeFrom(const ResolutionRequestAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InitialDocumentId = 1;
  inline bool has_initialdocumentid() const;
  inline void clear_initialdocumentid();
  static const int kInitialDocumentIdFieldNumber = 1;
  inline const ::std::string& initialdocumentid() const;
  inline void set_initialdocumentid(const ::std::string& value);
  inline void set_initialdocumentid(const char* value);
  inline void set_initialdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_initialdocumentid();
  inline ::std::string* release_initialdocumentid();
  inline void set_allocated_initialdocumentid(::std::string* initialdocumentid);

  // required .Diadoc.Api.Proto.Events.ResolutionRequestType Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestType type() const;
  inline void set_type(::Diadoc::Api::Proto::Events::ResolutionRequestType value);

  // optional string TargetUserId = 3;
  inline bool has_targetuserid() const;
  inline void clear_targetuserid();
  static const int kTargetUserIdFieldNumber = 3;
  inline const ::std::string& targetuserid() const;
  inline void set_targetuserid(const ::std::string& value);
  inline void set_targetuserid(const char* value);
  inline void set_targetuserid(const char* value, size_t size);
  inline ::std::string* mutable_targetuserid();
  inline ::std::string* release_targetuserid();
  inline void set_allocated_targetuserid(::std::string* targetuserid);

  // optional string TargetDepartmentId = 4;
  inline bool has_targetdepartmentid() const;
  inline void clear_targetdepartmentid();
  static const int kTargetDepartmentIdFieldNumber = 4;
  inline const ::std::string& targetdepartmentid() const;
  inline void set_targetdepartmentid(const ::std::string& value);
  inline void set_targetdepartmentid(const char* value);
  inline void set_targetdepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_targetdepartmentid();
  inline ::std::string* release_targetdepartmentid();
  inline void set_allocated_targetdepartmentid(::std::string* targetdepartmentid);

  // optional string Comment = 5;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 5;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ResolutionRequestAttachment)
 private:
  inline void set_has_initialdocumentid();
  inline void clear_has_initialdocumentid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_targetuserid();
  inline void clear_has_targetuserid();
  inline void set_has_targetdepartmentid();
  inline void clear_has_targetdepartmentid();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* initialdocumentid_;
  ::std::string* targetuserid_;
  ::std::string* targetdepartmentid_;
  ::std::string* comment_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ResolutionRequestAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ResolutionRequestCancellationAttachment : public ::google::protobuf::Message {
 public:
  ResolutionRequestCancellationAttachment();
  virtual ~ResolutionRequestCancellationAttachment();

  ResolutionRequestCancellationAttachment(const ResolutionRequestCancellationAttachment& from);

  inline ResolutionRequestCancellationAttachment& operator=(const ResolutionRequestCancellationAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolutionRequestCancellationAttachment& default_instance();

  void Swap(ResolutionRequestCancellationAttachment* other);

  // implements Message ----------------------------------------------

  ResolutionRequestCancellationAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolutionRequestCancellationAttachment& from);
  void MergeFrom(const ResolutionRequestCancellationAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InitialResolutionRequestId = 1;
  inline bool has_initialresolutionrequestid() const;
  inline void clear_initialresolutionrequestid();
  static const int kInitialResolutionRequestIdFieldNumber = 1;
  inline const ::std::string& initialresolutionrequestid() const;
  inline void set_initialresolutionrequestid(const ::std::string& value);
  inline void set_initialresolutionrequestid(const char* value);
  inline void set_initialresolutionrequestid(const char* value, size_t size);
  inline ::std::string* mutable_initialresolutionrequestid();
  inline ::std::string* release_initialresolutionrequestid();
  inline void set_allocated_initialresolutionrequestid(::std::string* initialresolutionrequestid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ResolutionRequestCancellationAttachment)
 private:
  inline void set_has_initialresolutionrequestid();
  inline void clear_has_initialresolutionrequestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* initialresolutionrequestid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ResolutionRequestCancellationAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ResolutionRequestDenialCancellationAttachment : public ::google::protobuf::Message {
 public:
  ResolutionRequestDenialCancellationAttachment();
  virtual ~ResolutionRequestDenialCancellationAttachment();

  ResolutionRequestDenialCancellationAttachment(const ResolutionRequestDenialCancellationAttachment& from);

  inline ResolutionRequestDenialCancellationAttachment& operator=(const ResolutionRequestDenialCancellationAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolutionRequestDenialCancellationAttachment& default_instance();

  void Swap(ResolutionRequestDenialCancellationAttachment* other);

  // implements Message ----------------------------------------------

  ResolutionRequestDenialCancellationAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolutionRequestDenialCancellationAttachment& from);
  void MergeFrom(const ResolutionRequestDenialCancellationAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InitialResolutionRequestDenialId = 1;
  inline bool has_initialresolutionrequestdenialid() const;
  inline void clear_initialresolutionrequestdenialid();
  static const int kInitialResolutionRequestDenialIdFieldNumber = 1;
  inline const ::std::string& initialresolutionrequestdenialid() const;
  inline void set_initialresolutionrequestdenialid(const ::std::string& value);
  inline void set_initialresolutionrequestdenialid(const char* value);
  inline void set_initialresolutionrequestdenialid(const char* value, size_t size);
  inline ::std::string* mutable_initialresolutionrequestdenialid();
  inline ::std::string* release_initialresolutionrequestdenialid();
  inline void set_allocated_initialresolutionrequestdenialid(::std::string* initialresolutionrequestdenialid);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ResolutionRequestDenialCancellationAttachment)
 private:
  inline void set_has_initialresolutionrequestdenialid();
  inline void clear_has_initialresolutionrequestdenialid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* initialresolutionrequestdenialid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ResolutionRequestDenialCancellationAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ResolutionRequestDenialAttachment : public ::google::protobuf::Message {
 public:
  ResolutionRequestDenialAttachment();
  virtual ~ResolutionRequestDenialAttachment();

  ResolutionRequestDenialAttachment(const ResolutionRequestDenialAttachment& from);

  inline ResolutionRequestDenialAttachment& operator=(const ResolutionRequestDenialAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolutionRequestDenialAttachment& default_instance();

  void Swap(ResolutionRequestDenialAttachment* other);

  // implements Message ----------------------------------------------

  ResolutionRequestDenialAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolutionRequestDenialAttachment& from);
  void MergeFrom(const ResolutionRequestDenialAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InitialResolutionRequestId = 1;
  inline bool has_initialresolutionrequestid() const;
  inline void clear_initialresolutionrequestid();
  static const int kInitialResolutionRequestIdFieldNumber = 1;
  inline const ::std::string& initialresolutionrequestid() const;
  inline void set_initialresolutionrequestid(const ::std::string& value);
  inline void set_initialresolutionrequestid(const char* value);
  inline void set_initialresolutionrequestid(const char* value, size_t size);
  inline ::std::string* mutable_initialresolutionrequestid();
  inline ::std::string* release_initialresolutionrequestid();
  inline void set_allocated_initialresolutionrequestid(::std::string* initialresolutionrequestid);

  // optional string Comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ResolutionRequestDenialAttachment)
 private:
  inline void set_has_initialresolutionrequestid();
  inline void clear_has_initialresolutionrequestid();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* initialresolutionrequestid_;
  ::std::string* comment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ResolutionRequestDenialAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ResolutionAttachment : public ::google::protobuf::Message {
 public:
  ResolutionAttachment();
  virtual ~ResolutionAttachment();

  ResolutionAttachment(const ResolutionAttachment& from);

  inline ResolutionAttachment& operator=(const ResolutionAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolutionAttachment& default_instance();

  void Swap(ResolutionAttachment* other);

  // implements Message ----------------------------------------------

  ResolutionAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolutionAttachment& from);
  void MergeFrom(const ResolutionAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string InitialDocumentId = 1;
  inline bool has_initialdocumentid() const;
  inline void clear_initialdocumentid();
  static const int kInitialDocumentIdFieldNumber = 1;
  inline const ::std::string& initialdocumentid() const;
  inline void set_initialdocumentid(const ::std::string& value);
  inline void set_initialdocumentid(const char* value);
  inline void set_initialdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_initialdocumentid();
  inline ::std::string* release_initialdocumentid();
  inline void set_allocated_initialdocumentid(::std::string* initialdocumentid);

  // required .Diadoc.Api.Proto.Events.ResolutionType ResolutionType = 2;
  inline bool has_resolutiontype() const;
  inline void clear_resolutiontype();
  static const int kResolutionTypeFieldNumber = 2;
  inline ::Diadoc::Api::Proto::Events::ResolutionType resolutiontype() const;
  inline void set_resolutiontype(::Diadoc::Api::Proto::Events::ResolutionType value);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ResolutionAttachment)
 private:
  inline void set_has_initialdocumentid();
  inline void clear_has_initialdocumentid();
  inline void set_has_resolutiontype();
  inline void clear_has_resolutiontype();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* initialdocumentid_;
  ::std::string* comment_;
  int resolutiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ResolutionAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ReceiptAttachment : public ::google::protobuf::Message {
 public:
  ReceiptAttachment();
  virtual ~ReceiptAttachment();

  ReceiptAttachment(const ReceiptAttachment& from);

  inline ReceiptAttachment& operator=(const ReceiptAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiptAttachment& default_instance();

  void Swap(ReceiptAttachment* other);

  // implements Message ----------------------------------------------

  ReceiptAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiptAttachment& from);
  void MergeFrom(const ReceiptAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ParentEntityId = 1;
  inline bool has_parententityid() const;
  inline void clear_parententityid();
  static const int kParentEntityIdFieldNumber = 1;
  inline const ::std::string& parententityid() const;
  inline void set_parententityid(const ::std::string& value);
  inline void set_parententityid(const char* value);
  inline void set_parententityid(const char* value, size_t size);
  inline ::std::string* mutable_parententityid();
  inline ::std::string* release_parententityid();
  inline void set_allocated_parententityid(::std::string* parententityid);

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.ReceiptAttachment)
 private:
  inline void set_has_parententityid();
  inline void clear_has_parententityid();
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parententityid_;
  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static ReceiptAttachment* default_instance_;
};
// -------------------------------------------------------------------

class CorrectionRequestAttachment : public ::google::protobuf::Message {
 public:
  CorrectionRequestAttachment();
  virtual ~CorrectionRequestAttachment();

  CorrectionRequestAttachment(const CorrectionRequestAttachment& from);

  inline CorrectionRequestAttachment& operator=(const CorrectionRequestAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CorrectionRequestAttachment& default_instance();

  void Swap(CorrectionRequestAttachment* other);

  // implements Message ----------------------------------------------

  CorrectionRequestAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CorrectionRequestAttachment& from);
  void MergeFrom(const CorrectionRequestAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ParentEntityId = 1;
  inline bool has_parententityid() const;
  inline void clear_parententityid();
  static const int kParentEntityIdFieldNumber = 1;
  inline const ::std::string& parententityid() const;
  inline void set_parententityid(const ::std::string& value);
  inline void set_parententityid(const char* value);
  inline void set_parententityid(const char* value, size_t size);
  inline ::std::string* mutable_parententityid();
  inline ::std::string* release_parententityid();
  inline void set_allocated_parententityid(::std::string* parententityid);

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.CorrectionRequestAttachment)
 private:
  inline void set_has_parententityid();
  inline void clear_has_parententityid();
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parententityid_;
  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static CorrectionRequestAttachment* default_instance_;
};
// -------------------------------------------------------------------

class DocumentSignature : public ::google::protobuf::Message {
 public:
  DocumentSignature();
  virtual ~DocumentSignature();

  DocumentSignature(const DocumentSignature& from);

  inline DocumentSignature& operator=(const DocumentSignature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentSignature& default_instance();

  void Swap(DocumentSignature* other);

  // implements Message ----------------------------------------------

  DocumentSignature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentSignature& from);
  void MergeFrom(const DocumentSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ParentEntityId = 1;
  inline bool has_parententityid() const;
  inline void clear_parententityid();
  static const int kParentEntityIdFieldNumber = 1;
  inline const ::std::string& parententityid() const;
  inline void set_parententityid(const ::std::string& value);
  inline void set_parententityid(const char* value);
  inline void set_parententityid(const char* value, size_t size);
  inline ::std::string* mutable_parententityid();
  inline ::std::string* release_parententityid();
  inline void set_allocated_parententityid(::std::string* parententityid);

  // optional bytes Signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bool SignByAttorney = 3 [default = false];
  inline bool has_signbyattorney() const;
  inline void clear_signbyattorney();
  static const int kSignByAttorneyFieldNumber = 3;
  inline bool signbyattorney() const;
  inline void set_signbyattorney(bool value);

  // optional bool SignWithTestSignature = 4 [default = false];
  inline bool has_signwithtestsignature() const;
  inline void clear_signwithtestsignature();
  static const int kSignWithTestSignatureFieldNumber = 4;
  inline bool signwithtestsignature() const;
  inline void set_signwithtestsignature(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.DocumentSignature)
 private:
  inline void set_has_parententityid();
  inline void clear_has_parententityid();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_signbyattorney();
  inline void clear_has_signbyattorney();
  inline void set_has_signwithtestsignature();
  inline void clear_has_signwithtestsignature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parententityid_;
  ::std::string* signature_;
  bool signbyattorney_;
  bool signwithtestsignature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static DocumentSignature* default_instance_;
};
// -------------------------------------------------------------------

class RequestedSignatureRejection : public ::google::protobuf::Message {
 public:
  RequestedSignatureRejection();
  virtual ~RequestedSignatureRejection();

  RequestedSignatureRejection(const RequestedSignatureRejection& from);

  inline RequestedSignatureRejection& operator=(const RequestedSignatureRejection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestedSignatureRejection& default_instance();

  void Swap(RequestedSignatureRejection* other);

  // implements Message ----------------------------------------------

  RequestedSignatureRejection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestedSignatureRejection& from);
  void MergeFrom(const RequestedSignatureRejection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ParentEntityId = 1;
  inline bool has_parententityid() const;
  inline void clear_parententityid();
  static const int kParentEntityIdFieldNumber = 1;
  inline const ::std::string& parententityid() const;
  inline void set_parententityid(const ::std::string& value);
  inline void set_parententityid(const char* value);
  inline void set_parententityid(const char* value, size_t size);
  inline ::std::string* mutable_parententityid();
  inline ::std::string* release_parententityid();
  inline void set_allocated_parententityid(::std::string* parententityid);

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.RequestedSignatureRejection)
 private:
  inline void set_has_parententityid();
  inline void clear_has_parententityid();
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parententityid_;
  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static RequestedSignatureRejection* default_instance_;
};
// -------------------------------------------------------------------

class SignedContent : public ::google::protobuf::Message {
 public:
  SignedContent();
  virtual ~SignedContent();

  SignedContent(const SignedContent& from);

  inline SignedContent& operator=(const SignedContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedContent& default_instance();

  void Swap(SignedContent* other);

  // implements Message ----------------------------------------------

  SignedContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedContent& from);
  void MergeFrom(const SignedContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes Content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional bytes Signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bool SignByAttorney = 3 [default = false];
  inline bool has_signbyattorney() const;
  inline void clear_signbyattorney();
  static const int kSignByAttorneyFieldNumber = 3;
  inline bool signbyattorney() const;
  inline void set_signbyattorney(bool value);

  // optional string NameOnShelf = 4;
  inline bool has_nameonshelf() const;
  inline void clear_nameonshelf();
  static const int kNameOnShelfFieldNumber = 4;
  inline const ::std::string& nameonshelf() const;
  inline void set_nameonshelf(const ::std::string& value);
  inline void set_nameonshelf(const char* value);
  inline void set_nameonshelf(const char* value, size_t size);
  inline ::std::string* mutable_nameonshelf();
  inline ::std::string* release_nameonshelf();
  inline void set_allocated_nameonshelf(::std::string* nameonshelf);

  // optional bool SignWithTestSignature = 5 [default = false];
  inline bool has_signwithtestsignature() const;
  inline void clear_signwithtestsignature();
  static const int kSignWithTestSignatureFieldNumber = 5;
  inline bool signwithtestsignature() const;
  inline void set_signwithtestsignature(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.SignedContent)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_signbyattorney();
  inline void clear_has_signbyattorney();
  inline void set_has_nameonshelf();
  inline void clear_has_nameonshelf();
  inline void set_has_signwithtestsignature();
  inline void clear_has_signwithtestsignature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::std::string* signature_;
  ::std::string* nameonshelf_;
  bool signbyattorney_;
  bool signwithtestsignature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static SignedContent* default_instance_;
};
// -------------------------------------------------------------------

class DraftToSend : public ::google::protobuf::Message {
 public:
  DraftToSend();
  virtual ~DraftToSend();

  DraftToSend(const DraftToSend& from);

  inline DraftToSend& operator=(const DraftToSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DraftToSend& default_instance();

  void Swap(DraftToSend* other);

  // implements Message ----------------------------------------------

  DraftToSend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DraftToSend& from);
  void MergeFrom(const DraftToSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string BoxId = 1;
  inline bool has_boxid() const;
  inline void clear_boxid();
  static const int kBoxIdFieldNumber = 1;
  inline const ::std::string& boxid() const;
  inline void set_boxid(const ::std::string& value);
  inline void set_boxid(const char* value);
  inline void set_boxid(const char* value, size_t size);
  inline ::std::string* mutable_boxid();
  inline ::std::string* release_boxid();
  inline void set_allocated_boxid(::std::string* boxid);

  // required string DraftId = 2;
  inline bool has_draftid() const;
  inline void clear_draftid();
  static const int kDraftIdFieldNumber = 2;
  inline const ::std::string& draftid() const;
  inline void set_draftid(const ::std::string& value);
  inline void set_draftid(const char* value);
  inline void set_draftid(const char* value, size_t size);
  inline ::std::string* mutable_draftid();
  inline ::std::string* release_draftid();
  inline void set_allocated_draftid(::std::string* draftid);

  // optional string ToBoxId = 3;
  inline bool has_toboxid() const;
  inline void clear_toboxid();
  static const int kToBoxIdFieldNumber = 3;
  inline const ::std::string& toboxid() const;
  inline void set_toboxid(const ::std::string& value);
  inline void set_toboxid(const char* value);
  inline void set_toboxid(const char* value, size_t size);
  inline ::std::string* mutable_toboxid();
  inline ::std::string* release_toboxid();
  inline void set_allocated_toboxid(::std::string* toboxid);

  // optional string ToDepartmentId = 4;
  inline bool has_todepartmentid() const;
  inline void clear_todepartmentid();
  static const int kToDepartmentIdFieldNumber = 4;
  inline const ::std::string& todepartmentid() const;
  inline void set_todepartmentid(const ::std::string& value);
  inline void set_todepartmentid(const char* value);
  inline void set_todepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_todepartmentid();
  inline ::std::string* release_todepartmentid();
  inline void set_allocated_todepartmentid(::std::string* todepartmentid);

  // repeated .Diadoc.Api.Proto.Events.DocumentSignature DocumentSignatures = 5;
  inline int documentsignatures_size() const;
  inline void clear_documentsignatures();
  static const int kDocumentSignaturesFieldNumber = 5;
  inline const ::Diadoc::Api::Proto::Events::DocumentSignature& documentsignatures(int index) const;
  inline ::Diadoc::Api::Proto::Events::DocumentSignature* mutable_documentsignatures(int index);
  inline ::Diadoc::Api::Proto::Events::DocumentSignature* add_documentsignatures();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >&
      documentsignatures() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >*
      mutable_documentsignatures();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.DraftToSend)
 private:
  inline void set_has_boxid();
  inline void clear_has_boxid();
  inline void set_has_draftid();
  inline void clear_has_draftid();
  inline void set_has_toboxid();
  inline void clear_has_toboxid();
  inline void set_has_todepartmentid();
  inline void clear_has_todepartmentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* boxid_;
  ::std::string* draftid_;
  ::std::string* toboxid_;
  ::std::string* todepartmentid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature > documentsignatures_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static DraftToSend* default_instance_;
};
// -------------------------------------------------------------------

class MessageToSend : public ::google::protobuf::Message {
 public:
  MessageToSend();
  virtual ~MessageToSend();

  MessageToSend(const MessageToSend& from);

  inline MessageToSend& operator=(const MessageToSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageToSend& default_instance();

  void Swap(MessageToSend* other);

  // implements Message ----------------------------------------------

  MessageToSend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageToSend& from);
  void MergeFrom(const MessageToSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string BoxId = 1;
  inline bool has_boxid() const;
  inline void clear_boxid();
  static const int kBoxIdFieldNumber = 1;
  inline const ::std::string& boxid() const;
  inline void set_boxid(const ::std::string& value);
  inline void set_boxid(const char* value);
  inline void set_boxid(const char* value, size_t size);
  inline ::std::string* mutable_boxid();
  inline ::std::string* release_boxid();
  inline void set_allocated_boxid(::std::string* boxid);

  // required string MessageId = 2;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 2;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  inline void set_allocated_messageid(::std::string* messageid);

  // repeated .Diadoc.Api.Proto.Events.DocumentSignature DocumentSignatures = 3;
  inline int documentsignatures_size() const;
  inline void clear_documentsignatures();
  static const int kDocumentSignaturesFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Events::DocumentSignature& documentsignatures(int index) const;
  inline ::Diadoc::Api::Proto::Events::DocumentSignature* mutable_documentsignatures(int index);
  inline ::Diadoc::Api::Proto::Events::DocumentSignature* add_documentsignatures();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >&
      documentsignatures() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >*
      mutable_documentsignatures();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.MessageToSend)
 private:
  inline void set_has_boxid();
  inline void clear_has_boxid();
  inline void set_has_messageid();
  inline void clear_has_messageid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* boxid_;
  ::std::string* messageid_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature > documentsignatures_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static MessageToSend* default_instance_;
};
// -------------------------------------------------------------------

class RevocationRequestAttachment : public ::google::protobuf::Message {
 public:
  RevocationRequestAttachment();
  virtual ~RevocationRequestAttachment();

  RevocationRequestAttachment(const RevocationRequestAttachment& from);

  inline RevocationRequestAttachment& operator=(const RevocationRequestAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RevocationRequestAttachment& default_instance();

  void Swap(RevocationRequestAttachment* other);

  // implements Message ----------------------------------------------

  RevocationRequestAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RevocationRequestAttachment& from);
  void MergeFrom(const RevocationRequestAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ParentEntityId = 1;
  inline bool has_parententityid() const;
  inline void clear_parententityid();
  static const int kParentEntityIdFieldNumber = 1;
  inline const ::std::string& parententityid() const;
  inline void set_parententityid(const ::std::string& value);
  inline void set_parententityid(const char* value);
  inline void set_parententityid(const char* value, size_t size);
  inline ::std::string* mutable_parententityid();
  inline ::std::string* release_parententityid();
  inline void set_allocated_parententityid(::std::string* parententityid);

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.RevocationRequestAttachment)
 private:
  inline void set_has_parententityid();
  inline void clear_has_parententityid();
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parententityid_;
  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static RevocationRequestAttachment* default_instance_;
};
// -------------------------------------------------------------------

class XmlSignatureRejectionAttachment : public ::google::protobuf::Message {
 public:
  XmlSignatureRejectionAttachment();
  virtual ~XmlSignatureRejectionAttachment();

  XmlSignatureRejectionAttachment(const XmlSignatureRejectionAttachment& from);

  inline XmlSignatureRejectionAttachment& operator=(const XmlSignatureRejectionAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XmlSignatureRejectionAttachment& default_instance();

  void Swap(XmlSignatureRejectionAttachment* other);

  // implements Message ----------------------------------------------

  XmlSignatureRejectionAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XmlSignatureRejectionAttachment& from);
  void MergeFrom(const XmlSignatureRejectionAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ParentEntityId = 1;
  inline bool has_parententityid() const;
  inline void clear_parententityid();
  static const int kParentEntityIdFieldNumber = 1;
  inline const ::std::string& parententityid() const;
  inline void set_parententityid(const ::std::string& value);
  inline void set_parententityid(const char* value);
  inline void set_parententityid(const char* value, size_t size);
  inline ::std::string* mutable_parententityid();
  inline ::std::string* release_parententityid();
  inline void set_allocated_parententityid(::std::string* parententityid);

  // required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Events::SignedContent& signedcontent() const;
  inline ::Diadoc::Api::Proto::Events::SignedContent* mutable_signedcontent();
  inline ::Diadoc::Api::Proto::Events::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.XmlSignatureRejectionAttachment)
 private:
  inline void set_has_parententityid();
  inline void clear_has_parententityid();
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parententityid_;
  ::Diadoc::Api::Proto::Events::SignedContent* signedcontent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2ePostApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2ePostApi_2eproto();

  void InitAsDefaultInstance();
  static XmlSignatureRejectionAttachment* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageToPost

// required string FromBoxId = 1;
inline bool MessageToPost::has_fromboxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageToPost::set_has_fromboxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageToPost::clear_has_fromboxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageToPost::clear_fromboxid() {
  if (fromboxid_ != &::google::protobuf::internal::kEmptyString) {
    fromboxid_->clear();
  }
  clear_has_fromboxid();
}
inline const ::std::string& MessageToPost::fromboxid() const {
  return *fromboxid_;
}
inline void MessageToPost::set_fromboxid(const ::std::string& value) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(value);
}
inline void MessageToPost::set_fromboxid(const char* value) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(value);
}
inline void MessageToPost::set_fromboxid(const char* value, size_t size) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_fromboxid() {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  return fromboxid_;
}
inline ::std::string* MessageToPost::release_fromboxid() {
  clear_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromboxid_;
    fromboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_fromboxid(::std::string* fromboxid) {
  if (fromboxid_ != &::google::protobuf::internal::kEmptyString) {
    delete fromboxid_;
  }
  if (fromboxid) {
    set_has_fromboxid();
    fromboxid_ = fromboxid;
  } else {
    clear_has_fromboxid();
    fromboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ToBoxId = 2;
inline bool MessageToPost::has_toboxid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageToPost::set_has_toboxid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageToPost::clear_has_toboxid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageToPost::clear_toboxid() {
  if (toboxid_ != &::google::protobuf::internal::kEmptyString) {
    toboxid_->clear();
  }
  clear_has_toboxid();
}
inline const ::std::string& MessageToPost::toboxid() const {
  return *toboxid_;
}
inline void MessageToPost::set_toboxid(const ::std::string& value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void MessageToPost::set_toboxid(const char* value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void MessageToPost::set_toboxid(const char* value, size_t size) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_toboxid() {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  return toboxid_;
}
inline ::std::string* MessageToPost::release_toboxid() {
  clear_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toboxid_;
    toboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_toboxid(::std::string* toboxid) {
  if (toboxid_ != &::google::protobuf::internal::kEmptyString) {
    delete toboxid_;
  }
  if (toboxid) {
    set_has_toboxid();
    toboxid_ = toboxid;
  } else {
    clear_has_toboxid();
    toboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.Events.XmlDocumentAttachment Invoices = 3;
inline int MessageToPost::invoices_size() const {
  return invoices_.size();
}
inline void MessageToPost::clear_invoices() {
  invoices_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::XmlDocumentAttachment& MessageToPost::invoices(int index) const {
  return invoices_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* MessageToPost::mutable_invoices(int index) {
  return invoices_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* MessageToPost::add_invoices() {
  return invoices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >&
MessageToPost::invoices() const {
  return invoices_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >*
MessageToPost::mutable_invoices() {
  return &invoices_;
}

// repeated .Diadoc.Api.Proto.Events.NonformalizedAttachment NonformalizedDocuments = 4;
inline int MessageToPost::nonformalizeddocuments_size() const {
  return nonformalizeddocuments_.size();
}
inline void MessageToPost::clear_nonformalizeddocuments() {
  nonformalizeddocuments_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::NonformalizedAttachment& MessageToPost::nonformalizeddocuments(int index) const {
  return nonformalizeddocuments_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* MessageToPost::mutable_nonformalizeddocuments(int index) {
  return nonformalizeddocuments_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* MessageToPost::add_nonformalizeddocuments() {
  return nonformalizeddocuments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >&
MessageToPost::nonformalizeddocuments() const {
  return nonformalizeddocuments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >*
MessageToPost::mutable_nonformalizeddocuments() {
  return &nonformalizeddocuments_;
}

// repeated .Diadoc.Api.Proto.Events.BasicDocumentAttachment Torg12Documents = 5;
inline int MessageToPost::torg12documents_size() const {
  return torg12documents_.size();
}
inline void MessageToPost::clear_torg12documents() {
  torg12documents_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::BasicDocumentAttachment& MessageToPost::torg12documents(int index) const {
  return torg12documents_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* MessageToPost::mutable_torg12documents(int index) {
  return torg12documents_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* MessageToPost::add_torg12documents() {
  return torg12documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >&
MessageToPost::torg12documents() const {
  return torg12documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >*
MessageToPost::mutable_torg12documents() {
  return &torg12documents_;
}

// optional .Diadoc.Api.Proto.Events.TrustConnectionRequestAttachment TrustConnectionRequest = 6;
inline bool MessageToPost::has_trustconnectionrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageToPost::set_has_trustconnectionrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageToPost::clear_has_trustconnectionrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageToPost::clear_trustconnectionrequest() {
  if (trustconnectionrequest_ != NULL) trustconnectionrequest_->::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment::Clear();
  clear_has_trustconnectionrequest();
}
inline const ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment& MessageToPost::trustconnectionrequest() const {
  return trustconnectionrequest_ != NULL ? *trustconnectionrequest_ : *default_instance_->trustconnectionrequest_;
}
inline ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* MessageToPost::mutable_trustconnectionrequest() {
  set_has_trustconnectionrequest();
  if (trustconnectionrequest_ == NULL) trustconnectionrequest_ = new ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment;
  return trustconnectionrequest_;
}
inline ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* MessageToPost::release_trustconnectionrequest() {
  clear_has_trustconnectionrequest();
  ::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* temp = trustconnectionrequest_;
  trustconnectionrequest_ = NULL;
  return temp;
}
inline void MessageToPost::set_allocated_trustconnectionrequest(::Diadoc::Api::Proto::Events::TrustConnectionRequestAttachment* trustconnectionrequest) {
  delete trustconnectionrequest_;
  trustconnectionrequest_ = trustconnectionrequest;
  if (trustconnectionrequest) {
    set_has_trustconnectionrequest();
  } else {
    clear_has_trustconnectionrequest();
  }
}

// repeated .Diadoc.Api.Proto.Events.AcceptanceCertificateAttachment AcceptanceCertificates = 7;
inline int MessageToPost::acceptancecertificates_size() const {
  return acceptancecertificates_.size();
}
inline void MessageToPost::clear_acceptancecertificates() {
  acceptancecertificates_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment& MessageToPost::acceptancecertificates(int index) const {
  return acceptancecertificates_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment* MessageToPost::mutable_acceptancecertificates(int index) {
  return acceptancecertificates_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment* MessageToPost::add_acceptancecertificates() {
  return acceptancecertificates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment >&
MessageToPost::acceptancecertificates() const {
  return acceptancecertificates_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::AcceptanceCertificateAttachment >*
MessageToPost::mutable_acceptancecertificates() {
  return &acceptancecertificates_;
}

// repeated .Diadoc.Api.Proto.Events.StructuredDataAttachment StructuredDataAttachments = 8;
inline int MessageToPost::structureddataattachments_size() const {
  return structureddataattachments_.size();
}
inline void MessageToPost::clear_structureddataattachments() {
  structureddataattachments_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::StructuredDataAttachment& MessageToPost::structureddataattachments(int index) const {
  return structureddataattachments_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::StructuredDataAttachment* MessageToPost::mutable_structureddataattachments(int index) {
  return structureddataattachments_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::StructuredDataAttachment* MessageToPost::add_structureddataattachments() {
  return structureddataattachments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::StructuredDataAttachment >&
MessageToPost::structureddataattachments() const {
  return structureddataattachments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::StructuredDataAttachment >*
MessageToPost::mutable_structureddataattachments() {
  return &structureddataattachments_;
}

// repeated .Diadoc.Api.Proto.Events.BasicDocumentAttachment ProformaInvoices = 9;
inline int MessageToPost::proformainvoices_size() const {
  return proformainvoices_.size();
}
inline void MessageToPost::clear_proformainvoices() {
  proformainvoices_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::BasicDocumentAttachment& MessageToPost::proformainvoices(int index) const {
  return proformainvoices_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* MessageToPost::mutable_proformainvoices(int index) {
  return proformainvoices_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::BasicDocumentAttachment* MessageToPost::add_proformainvoices() {
  return proformainvoices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >&
MessageToPost::proformainvoices() const {
  return proformainvoices_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BasicDocumentAttachment >*
MessageToPost::mutable_proformainvoices() {
  return &proformainvoices_;
}

// repeated .Diadoc.Api.Proto.Events.XmlDocumentAttachment XmlTorg12SellerTitles = 10;
inline int MessageToPost::xmltorg12sellertitles_size() const {
  return xmltorg12sellertitles_.size();
}
inline void MessageToPost::clear_xmltorg12sellertitles() {
  xmltorg12sellertitles_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::XmlDocumentAttachment& MessageToPost::xmltorg12sellertitles(int index) const {
  return xmltorg12sellertitles_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* MessageToPost::mutable_xmltorg12sellertitles(int index) {
  return xmltorg12sellertitles_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* MessageToPost::add_xmltorg12sellertitles() {
  return xmltorg12sellertitles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >&
MessageToPost::xmltorg12sellertitles() const {
  return xmltorg12sellertitles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >*
MessageToPost::mutable_xmltorg12sellertitles() {
  return &xmltorg12sellertitles_;
}

// repeated .Diadoc.Api.Proto.Events.XmlDocumentAttachment XmlAcceptanceCertificateSellerTitles = 11;
inline int MessageToPost::xmlacceptancecertificatesellertitles_size() const {
  return xmlacceptancecertificatesellertitles_.size();
}
inline void MessageToPost::clear_xmlacceptancecertificatesellertitles() {
  xmlacceptancecertificatesellertitles_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::XmlDocumentAttachment& MessageToPost::xmlacceptancecertificatesellertitles(int index) const {
  return xmlacceptancecertificatesellertitles_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* MessageToPost::mutable_xmlacceptancecertificatesellertitles(int index) {
  return xmlacceptancecertificatesellertitles_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::XmlDocumentAttachment* MessageToPost::add_xmlacceptancecertificatesellertitles() {
  return xmlacceptancecertificatesellertitles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >&
MessageToPost::xmlacceptancecertificatesellertitles() const {
  return xmlacceptancecertificatesellertitles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlDocumentAttachment >*
MessageToPost::mutable_xmlacceptancecertificatesellertitles() {
  return &xmlacceptancecertificatesellertitles_;
}

// optional string ToDepartmentId = 12;
inline bool MessageToPost::has_todepartmentid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MessageToPost::set_has_todepartmentid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MessageToPost::clear_has_todepartmentid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MessageToPost::clear_todepartmentid() {
  if (todepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    todepartmentid_->clear();
  }
  clear_has_todepartmentid();
}
inline const ::std::string& MessageToPost::todepartmentid() const {
  return *todepartmentid_;
}
inline void MessageToPost::set_todepartmentid(const ::std::string& value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void MessageToPost::set_todepartmentid(const char* value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void MessageToPost::set_todepartmentid(const char* value, size_t size) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_todepartmentid() {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  return todepartmentid_;
}
inline ::std::string* MessageToPost::release_todepartmentid() {
  clear_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todepartmentid_;
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_todepartmentid(::std::string* todepartmentid) {
  if (todepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete todepartmentid_;
  }
  if (todepartmentid) {
    set_has_todepartmentid();
    todepartmentid_ = todepartmentid;
  } else {
    clear_has_todepartmentid();
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsDraft = 13 [default = false];
inline bool MessageToPost::has_isdraft() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MessageToPost::set_has_isdraft() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MessageToPost::clear_has_isdraft() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MessageToPost::clear_isdraft() {
  isdraft_ = false;
  clear_has_isdraft();
}
inline bool MessageToPost::isdraft() const {
  return isdraft_;
}
inline void MessageToPost::set_isdraft(bool value) {
  set_has_isdraft();
  isdraft_ = value;
}

// optional bool LockDraft = 14 [default = false];
inline bool MessageToPost::has_lockdraft() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MessageToPost::set_has_lockdraft() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MessageToPost::clear_has_lockdraft() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MessageToPost::clear_lockdraft() {
  lockdraft_ = false;
  clear_has_lockdraft();
}
inline bool MessageToPost::lockdraft() const {
  return lockdraft_;
}
inline void MessageToPost::set_lockdraft(bool value) {
  set_has_lockdraft();
  lockdraft_ = value;
}

// optional bool StrictDraftValidation = 15 [default = true];
inline bool MessageToPost::has_strictdraftvalidation() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MessageToPost::set_has_strictdraftvalidation() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MessageToPost::clear_has_strictdraftvalidation() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MessageToPost::clear_strictdraftvalidation() {
  strictdraftvalidation_ = true;
  clear_has_strictdraftvalidation();
}
inline bool MessageToPost::strictdraftvalidation() const {
  return strictdraftvalidation_;
}
inline void MessageToPost::set_strictdraftvalidation(bool value) {
  set_has_strictdraftvalidation();
  strictdraftvalidation_ = value;
}

// optional bool IsInternal = 16 [default = false];
inline bool MessageToPost::has_isinternal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MessageToPost::set_has_isinternal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MessageToPost::clear_has_isinternal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MessageToPost::clear_isinternal() {
  isinternal_ = false;
  clear_has_isinternal();
}
inline bool MessageToPost::isinternal() const {
  return isinternal_;
}
inline void MessageToPost::set_isinternal(bool value) {
  set_has_isinternal();
  isinternal_ = value;
}

// optional string FromDepartmentId = 17;
inline bool MessageToPost::has_fromdepartmentid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MessageToPost::set_has_fromdepartmentid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MessageToPost::clear_has_fromdepartmentid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MessageToPost::clear_fromdepartmentid() {
  if (fromdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_->clear();
  }
  clear_has_fromdepartmentid();
}
inline const ::std::string& MessageToPost::fromdepartmentid() const {
  return *fromdepartmentid_;
}
inline void MessageToPost::set_fromdepartmentid(const ::std::string& value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
}
inline void MessageToPost::set_fromdepartmentid(const char* value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
}
inline void MessageToPost::set_fromdepartmentid(const char* value, size_t size) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_fromdepartmentid() {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  return fromdepartmentid_;
}
inline ::std::string* MessageToPost::release_fromdepartmentid() {
  clear_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromdepartmentid_;
    fromdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_fromdepartmentid(::std::string* fromdepartmentid) {
  if (fromdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete fromdepartmentid_;
  }
  if (fromdepartmentid) {
    set_has_fromdepartmentid();
    fromdepartmentid_ = fromdepartmentid;
  } else {
    clear_has_fromdepartmentid();
    fromdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool DelaySend = 18 [default = false];
inline bool MessageToPost::has_delaysend() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MessageToPost::set_has_delaysend() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MessageToPost::clear_has_delaysend() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MessageToPost::clear_delaysend() {
  delaysend_ = false;
  clear_has_delaysend();
}
inline bool MessageToPost::delaysend() const {
  return delaysend_;
}
inline void MessageToPost::set_delaysend(bool value) {
  set_has_delaysend();
  delaysend_ = value;
}

// repeated .Diadoc.Api.Proto.Events.PriceListAttachment PriceLists = 19;
inline int MessageToPost::pricelists_size() const {
  return pricelists_.size();
}
inline void MessageToPost::clear_pricelists() {
  pricelists_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::PriceListAttachment& MessageToPost::pricelists(int index) const {
  return pricelists_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::PriceListAttachment* MessageToPost::mutable_pricelists(int index) {
  return pricelists_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::PriceListAttachment* MessageToPost::add_pricelists() {
  return pricelists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::PriceListAttachment >&
MessageToPost::pricelists() const {
  return pricelists_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::PriceListAttachment >*
MessageToPost::mutable_pricelists() {
  return &pricelists_;
}

// repeated .Diadoc.Api.Proto.Events.NonformalizedAttachment PriceListAgreements = 20;
inline int MessageToPost::pricelistagreements_size() const {
  return pricelistagreements_.size();
}
inline void MessageToPost::clear_pricelistagreements() {
  pricelistagreements_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::NonformalizedAttachment& MessageToPost::pricelistagreements(int index) const {
  return pricelistagreements_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* MessageToPost::mutable_pricelistagreements(int index) {
  return pricelistagreements_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* MessageToPost::add_pricelistagreements() {
  return pricelistagreements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >&
MessageToPost::pricelistagreements() const {
  return pricelistagreements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >*
MessageToPost::mutable_pricelistagreements() {
  return &pricelistagreements_;
}

// repeated .Diadoc.Api.Proto.Events.NonformalizedAttachment CertificateRegistries = 21;
inline int MessageToPost::certificateregistries_size() const {
  return certificateregistries_.size();
}
inline void MessageToPost::clear_certificateregistries() {
  certificateregistries_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::NonformalizedAttachment& MessageToPost::certificateregistries(int index) const {
  return certificateregistries_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* MessageToPost::mutable_certificateregistries(int index) {
  return certificateregistries_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::NonformalizedAttachment* MessageToPost::add_certificateregistries() {
  return certificateregistries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >&
MessageToPost::certificateregistries() const {
  return certificateregistries_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::NonformalizedAttachment >*
MessageToPost::mutable_certificateregistries() {
  return &certificateregistries_;
}

// repeated .Diadoc.Api.Proto.Events.ReconciliationActAttachment ReconciliationActs = 22;
inline int MessageToPost::reconciliationacts_size() const {
  return reconciliationacts_.size();
}
inline void MessageToPost::clear_reconciliationacts() {
  reconciliationacts_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ReconciliationActAttachment& MessageToPost::reconciliationacts(int index) const {
  return reconciliationacts_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ReconciliationActAttachment* MessageToPost::mutable_reconciliationacts(int index) {
  return reconciliationacts_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ReconciliationActAttachment* MessageToPost::add_reconciliationacts() {
  return reconciliationacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReconciliationActAttachment >&
MessageToPost::reconciliationacts() const {
  return reconciliationacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReconciliationActAttachment >*
MessageToPost::mutable_reconciliationacts() {
  return &reconciliationacts_;
}

// repeated .Diadoc.Api.Proto.Events.ContractAttachment Contracts = 23;
inline int MessageToPost::contracts_size() const {
  return contracts_.size();
}
inline void MessageToPost::clear_contracts() {
  contracts_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ContractAttachment& MessageToPost::contracts(int index) const {
  return contracts_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ContractAttachment* MessageToPost::mutable_contracts(int index) {
  return contracts_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ContractAttachment* MessageToPost::add_contracts() {
  return contracts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ContractAttachment >&
MessageToPost::contracts() const {
  return contracts_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ContractAttachment >*
MessageToPost::mutable_contracts() {
  return &contracts_;
}

// repeated .Diadoc.Api.Proto.Events.Torg13Attachment Torg13Documents = 24;
inline int MessageToPost::torg13documents_size() const {
  return torg13documents_.size();
}
inline void MessageToPost::clear_torg13documents() {
  torg13documents_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::Torg13Attachment& MessageToPost::torg13documents(int index) const {
  return torg13documents_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::Torg13Attachment* MessageToPost::mutable_torg13documents(int index) {
  return torg13documents_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::Torg13Attachment* MessageToPost::add_torg13documents() {
  return torg13documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Torg13Attachment >&
MessageToPost::torg13documents() const {
  return torg13documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Torg13Attachment >*
MessageToPost::mutable_torg13documents() {
  return &torg13documents_;
}

// repeated .Diadoc.Api.Proto.Events.ServiceDetailsAttachment ServiceDetailsDocuments = 25;
inline int MessageToPost::servicedetailsdocuments_size() const {
  return servicedetailsdocuments_.size();
}
inline void MessageToPost::clear_servicedetailsdocuments() {
  servicedetailsdocuments_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment& MessageToPost::servicedetailsdocuments(int index) const {
  return servicedetailsdocuments_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment* MessageToPost::mutable_servicedetailsdocuments(int index) {
  return servicedetailsdocuments_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment* MessageToPost::add_servicedetailsdocuments() {
  return servicedetailsdocuments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment >&
MessageToPost::servicedetailsdocuments() const {
  return servicedetailsdocuments_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ServiceDetailsAttachment >*
MessageToPost::mutable_servicedetailsdocuments() {
  return &servicedetailsdocuments_;
}

// -------------------------------------------------------------------

// XmlDocumentAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool XmlDocumentAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmlDocumentAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmlDocumentAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmlDocumentAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& XmlDocumentAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* XmlDocumentAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* XmlDocumentAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void XmlDocumentAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// optional string Comment = 3;
inline bool XmlDocumentAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmlDocumentAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmlDocumentAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmlDocumentAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& XmlDocumentAttachment::comment() const {
  return *comment_;
}
inline void XmlDocumentAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void XmlDocumentAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void XmlDocumentAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmlDocumentAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* XmlDocumentAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmlDocumentAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
inline int XmlDocumentAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void XmlDocumentAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& XmlDocumentAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* XmlDocumentAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* XmlDocumentAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
XmlDocumentAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
XmlDocumentAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
inline int XmlDocumentAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void XmlDocumentAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& XmlDocumentAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* XmlDocumentAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* XmlDocumentAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
XmlDocumentAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
XmlDocumentAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool XmlDocumentAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XmlDocumentAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XmlDocumentAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XmlDocumentAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& XmlDocumentAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void XmlDocumentAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void XmlDocumentAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void XmlDocumentAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmlDocumentAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* XmlDocumentAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmlDocumentAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 7 [default = false];
inline bool XmlDocumentAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XmlDocumentAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XmlDocumentAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XmlDocumentAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool XmlDocumentAttachment::needreceipt() const {
  return needreceipt_;
}
inline void XmlDocumentAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// NonformalizedAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool NonformalizedAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NonformalizedAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NonformalizedAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NonformalizedAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& NonformalizedAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* NonformalizedAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* NonformalizedAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void NonformalizedAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool NonformalizedAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NonformalizedAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NonformalizedAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NonformalizedAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& NonformalizedAttachment::filename() const {
  return *filename_;
}
inline void NonformalizedAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void NonformalizedAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void NonformalizedAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* NonformalizedAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool NonformalizedAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NonformalizedAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NonformalizedAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NonformalizedAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& NonformalizedAttachment::comment() const {
  return *comment_;
}
inline void NonformalizedAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void NonformalizedAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void NonformalizedAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* NonformalizedAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedRecipientSignature = 4 [default = false];
inline bool NonformalizedAttachment::has_needrecipientsignature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NonformalizedAttachment::set_has_needrecipientsignature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NonformalizedAttachment::clear_has_needrecipientsignature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NonformalizedAttachment::clear_needrecipientsignature() {
  needrecipientsignature_ = false;
  clear_has_needrecipientsignature();
}
inline bool NonformalizedAttachment::needrecipientsignature() const {
  return needrecipientsignature_;
}
inline void NonformalizedAttachment::set_needrecipientsignature(bool value) {
  set_has_needrecipientsignature();
  needrecipientsignature_ = value;
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 5;
inline int NonformalizedAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void NonformalizedAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& NonformalizedAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* NonformalizedAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* NonformalizedAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
NonformalizedAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
NonformalizedAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 6;
inline int NonformalizedAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void NonformalizedAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& NonformalizedAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* NonformalizedAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* NonformalizedAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
NonformalizedAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
NonformalizedAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string DocumentDate = 7;
inline bool NonformalizedAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NonformalizedAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NonformalizedAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NonformalizedAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& NonformalizedAttachment::documentdate() const {
  return *documentdate_;
}
inline void NonformalizedAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void NonformalizedAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void NonformalizedAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* NonformalizedAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DocumentNumber = 8;
inline bool NonformalizedAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NonformalizedAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NonformalizedAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NonformalizedAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& NonformalizedAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void NonformalizedAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void NonformalizedAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void NonformalizedAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* NonformalizedAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool NonformalizedAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NonformalizedAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NonformalizedAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NonformalizedAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& NonformalizedAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void NonformalizedAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void NonformalizedAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void NonformalizedAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* NonformalizedAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 10 [default = false];
inline bool NonformalizedAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NonformalizedAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NonformalizedAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NonformalizedAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool NonformalizedAttachment::needreceipt() const {
  return needreceipt_;
}
inline void NonformalizedAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// BasicDocumentAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool BasicDocumentAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicDocumentAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicDocumentAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicDocumentAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& BasicDocumentAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* BasicDocumentAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* BasicDocumentAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void BasicDocumentAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool BasicDocumentAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicDocumentAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicDocumentAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicDocumentAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& BasicDocumentAttachment::filename() const {
  return *filename_;
}
inline void BasicDocumentAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void BasicDocumentAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void BasicDocumentAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* BasicDocumentAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool BasicDocumentAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicDocumentAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicDocumentAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicDocumentAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& BasicDocumentAttachment::comment() const {
  return *comment_;
}
inline void BasicDocumentAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void BasicDocumentAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void BasicDocumentAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* BasicDocumentAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
inline int BasicDocumentAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void BasicDocumentAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& BasicDocumentAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* BasicDocumentAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* BasicDocumentAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
BasicDocumentAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
BasicDocumentAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
inline int BasicDocumentAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void BasicDocumentAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& BasicDocumentAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* BasicDocumentAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* BasicDocumentAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
BasicDocumentAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
BasicDocumentAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// required string DocumentDate = 6;
inline bool BasicDocumentAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BasicDocumentAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BasicDocumentAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BasicDocumentAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& BasicDocumentAttachment::documentdate() const {
  return *documentdate_;
}
inline void BasicDocumentAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void BasicDocumentAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void BasicDocumentAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* BasicDocumentAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 7;
inline bool BasicDocumentAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BasicDocumentAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BasicDocumentAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BasicDocumentAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& BasicDocumentAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void BasicDocumentAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void BasicDocumentAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void BasicDocumentAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* BasicDocumentAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Total = 8;
inline bool BasicDocumentAttachment::has_total() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BasicDocumentAttachment::set_has_total() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BasicDocumentAttachment::clear_has_total() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BasicDocumentAttachment::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& BasicDocumentAttachment::total() const {
  return *total_;
}
inline void BasicDocumentAttachment::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void BasicDocumentAttachment::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void BasicDocumentAttachment::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* BasicDocumentAttachment::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool BasicDocumentAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BasicDocumentAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BasicDocumentAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BasicDocumentAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& BasicDocumentAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void BasicDocumentAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void BasicDocumentAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void BasicDocumentAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* BasicDocumentAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Vat = 10;
inline bool BasicDocumentAttachment::has_vat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BasicDocumentAttachment::set_has_vat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BasicDocumentAttachment::clear_has_vat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BasicDocumentAttachment::clear_vat() {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& BasicDocumentAttachment::vat() const {
  return *vat_;
}
inline void BasicDocumentAttachment::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void BasicDocumentAttachment::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void BasicDocumentAttachment::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  return vat_;
}
inline ::std::string* BasicDocumentAttachment::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Grounds = 11;
inline bool BasicDocumentAttachment::has_grounds() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BasicDocumentAttachment::set_has_grounds() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BasicDocumentAttachment::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BasicDocumentAttachment::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& BasicDocumentAttachment::grounds() const {
  return *grounds_;
}
inline void BasicDocumentAttachment::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void BasicDocumentAttachment::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void BasicDocumentAttachment::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  return grounds_;
}
inline ::std::string* BasicDocumentAttachment::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 12 [default = false];
inline bool BasicDocumentAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BasicDocumentAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BasicDocumentAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BasicDocumentAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool BasicDocumentAttachment::needreceipt() const {
  return needreceipt_;
}
inline void BasicDocumentAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// Torg13Attachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool Torg13Attachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Torg13Attachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Torg13Attachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Torg13Attachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& Torg13Attachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* Torg13Attachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* Torg13Attachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void Torg13Attachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool Torg13Attachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Torg13Attachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Torg13Attachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Torg13Attachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Torg13Attachment::filename() const {
  return *filename_;
}
inline void Torg13Attachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Torg13Attachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Torg13Attachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Torg13Attachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool Torg13Attachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Torg13Attachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Torg13Attachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Torg13Attachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Torg13Attachment::comment() const {
  return *comment_;
}
inline void Torg13Attachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Torg13Attachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Torg13Attachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* Torg13Attachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
inline int Torg13Attachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void Torg13Attachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& Torg13Attachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* Torg13Attachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* Torg13Attachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
Torg13Attachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
Torg13Attachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
inline int Torg13Attachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void Torg13Attachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& Torg13Attachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* Torg13Attachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* Torg13Attachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
Torg13Attachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
Torg13Attachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// required string DocumentDate = 6;
inline bool Torg13Attachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Torg13Attachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Torg13Attachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Torg13Attachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& Torg13Attachment::documentdate() const {
  return *documentdate_;
}
inline void Torg13Attachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void Torg13Attachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void Torg13Attachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* Torg13Attachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 7;
inline bool Torg13Attachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Torg13Attachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Torg13Attachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Torg13Attachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& Torg13Attachment::documentnumber() const {
  return *documentnumber_;
}
inline void Torg13Attachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void Torg13Attachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void Torg13Attachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* Torg13Attachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Total = 8;
inline bool Torg13Attachment::has_total() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Torg13Attachment::set_has_total() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Torg13Attachment::clear_has_total() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Torg13Attachment::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& Torg13Attachment::total() const {
  return *total_;
}
inline void Torg13Attachment::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void Torg13Attachment::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void Torg13Attachment::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* Torg13Attachment::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool Torg13Attachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Torg13Attachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Torg13Attachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Torg13Attachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& Torg13Attachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void Torg13Attachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void Torg13Attachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void Torg13Attachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* Torg13Attachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Grounds = 11;
inline bool Torg13Attachment::has_grounds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Torg13Attachment::set_has_grounds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Torg13Attachment::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Torg13Attachment::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& Torg13Attachment::grounds() const {
  return *grounds_;
}
inline void Torg13Attachment::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void Torg13Attachment::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void Torg13Attachment::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  return grounds_;
}
inline ::std::string* Torg13Attachment::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 12 [default = false];
inline bool Torg13Attachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Torg13Attachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Torg13Attachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Torg13Attachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool Torg13Attachment::needreceipt() const {
  return needreceipt_;
}
inline void Torg13Attachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// AcceptanceCertificateAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool AcceptanceCertificateAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptanceCertificateAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptanceCertificateAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& AcceptanceCertificateAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* AcceptanceCertificateAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* AcceptanceCertificateAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void AcceptanceCertificateAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool AcceptanceCertificateAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptanceCertificateAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptanceCertificateAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& AcceptanceCertificateAttachment::filename() const {
  return *filename_;
}
inline void AcceptanceCertificateAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool AcceptanceCertificateAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcceptanceCertificateAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcceptanceCertificateAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& AcceptanceCertificateAttachment::comment() const {
  return *comment_;
}
inline void AcceptanceCertificateAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
inline int AcceptanceCertificateAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void AcceptanceCertificateAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& AcceptanceCertificateAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* AcceptanceCertificateAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* AcceptanceCertificateAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
AcceptanceCertificateAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
AcceptanceCertificateAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
inline int AcceptanceCertificateAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void AcceptanceCertificateAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& AcceptanceCertificateAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* AcceptanceCertificateAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* AcceptanceCertificateAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
AcceptanceCertificateAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
AcceptanceCertificateAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// required string DocumentDate = 6;
inline bool AcceptanceCertificateAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AcceptanceCertificateAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AcceptanceCertificateAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& AcceptanceCertificateAttachment::documentdate() const {
  return *documentdate_;
}
inline void AcceptanceCertificateAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 7;
inline bool AcceptanceCertificateAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AcceptanceCertificateAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AcceptanceCertificateAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& AcceptanceCertificateAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void AcceptanceCertificateAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Total = 8;
inline bool AcceptanceCertificateAttachment::has_total() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_total() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AcceptanceCertificateAttachment::clear_has_total() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AcceptanceCertificateAttachment::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& AcceptanceCertificateAttachment::total() const {
  return *total_;
}
inline void AcceptanceCertificateAttachment::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool AcceptanceCertificateAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AcceptanceCertificateAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AcceptanceCertificateAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& AcceptanceCertificateAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void AcceptanceCertificateAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Vat = 10;
inline bool AcceptanceCertificateAttachment::has_vat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_vat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AcceptanceCertificateAttachment::clear_has_vat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AcceptanceCertificateAttachment::clear_vat() {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& AcceptanceCertificateAttachment::vat() const {
  return *vat_;
}
inline void AcceptanceCertificateAttachment::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  return vat_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Grounds = 11;
inline bool AcceptanceCertificateAttachment::has_grounds() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_grounds() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AcceptanceCertificateAttachment::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AcceptanceCertificateAttachment::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& AcceptanceCertificateAttachment::grounds() const {
  return *grounds_;
}
inline void AcceptanceCertificateAttachment::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void AcceptanceCertificateAttachment::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateAttachment::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  return grounds_;
}
inline ::std::string* AcceptanceCertificateAttachment::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AcceptanceCertificateAttachment::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 12 [default = false];
inline bool AcceptanceCertificateAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AcceptanceCertificateAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AcceptanceCertificateAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool AcceptanceCertificateAttachment::needreceipt() const {
  return needreceipt_;
}
inline void AcceptanceCertificateAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// optional bool NeedRecipientSignature = 13 [default = true];
inline bool AcceptanceCertificateAttachment::has_needrecipientsignature() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AcceptanceCertificateAttachment::set_has_needrecipientsignature() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AcceptanceCertificateAttachment::clear_has_needrecipientsignature() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AcceptanceCertificateAttachment::clear_needrecipientsignature() {
  needrecipientsignature_ = true;
  clear_has_needrecipientsignature();
}
inline bool AcceptanceCertificateAttachment::needrecipientsignature() const {
  return needrecipientsignature_;
}
inline void AcceptanceCertificateAttachment::set_needrecipientsignature(bool value) {
  set_has_needrecipientsignature();
  needrecipientsignature_ = value;
}

// -------------------------------------------------------------------

// TrustConnectionRequestAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool TrustConnectionRequestAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrustConnectionRequestAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrustConnectionRequestAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& TrustConnectionRequestAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* TrustConnectionRequestAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* TrustConnectionRequestAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void TrustConnectionRequestAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool TrustConnectionRequestAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrustConnectionRequestAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrustConnectionRequestAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TrustConnectionRequestAttachment::filename() const {
  return *filename_;
}
inline void TrustConnectionRequestAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrustConnectionRequestAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TrustConnectionRequestAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrustConnectionRequestAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool TrustConnectionRequestAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrustConnectionRequestAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrustConnectionRequestAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& TrustConnectionRequestAttachment::comment() const {
  return *comment_;
}
inline void TrustConnectionRequestAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrustConnectionRequestAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* TrustConnectionRequestAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrustConnectionRequestAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 4;
inline bool TrustConnectionRequestAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrustConnectionRequestAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrustConnectionRequestAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& TrustConnectionRequestAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void TrustConnectionRequestAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrustConnectionRequestAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* TrustConnectionRequestAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrustConnectionRequestAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StructuredDataAttachment

// required bytes Content = 1;
inline bool StructuredDataAttachment::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StructuredDataAttachment::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StructuredDataAttachment::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StructuredDataAttachment::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& StructuredDataAttachment::content() const {
  return *content_;
}
inline void StructuredDataAttachment::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void StructuredDataAttachment::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void StructuredDataAttachment::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StructuredDataAttachment::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* StructuredDataAttachment::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StructuredDataAttachment::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FileName = 2;
inline bool StructuredDataAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StructuredDataAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StructuredDataAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StructuredDataAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& StructuredDataAttachment::filename() const {
  return *filename_;
}
inline void StructuredDataAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void StructuredDataAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void StructuredDataAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StructuredDataAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* StructuredDataAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StructuredDataAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ParentCustomDocumentId = 3;
inline bool StructuredDataAttachment::has_parentcustomdocumentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StructuredDataAttachment::set_has_parentcustomdocumentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StructuredDataAttachment::clear_has_parentcustomdocumentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StructuredDataAttachment::clear_parentcustomdocumentid() {
  if (parentcustomdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    parentcustomdocumentid_->clear();
  }
  clear_has_parentcustomdocumentid();
}
inline const ::std::string& StructuredDataAttachment::parentcustomdocumentid() const {
  return *parentcustomdocumentid_;
}
inline void StructuredDataAttachment::set_parentcustomdocumentid(const ::std::string& value) {
  set_has_parentcustomdocumentid();
  if (parentcustomdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    parentcustomdocumentid_ = new ::std::string;
  }
  parentcustomdocumentid_->assign(value);
}
inline void StructuredDataAttachment::set_parentcustomdocumentid(const char* value) {
  set_has_parentcustomdocumentid();
  if (parentcustomdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    parentcustomdocumentid_ = new ::std::string;
  }
  parentcustomdocumentid_->assign(value);
}
inline void StructuredDataAttachment::set_parentcustomdocumentid(const char* value, size_t size) {
  set_has_parentcustomdocumentid();
  if (parentcustomdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    parentcustomdocumentid_ = new ::std::string;
  }
  parentcustomdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StructuredDataAttachment::mutable_parentcustomdocumentid() {
  set_has_parentcustomdocumentid();
  if (parentcustomdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    parentcustomdocumentid_ = new ::std::string;
  }
  return parentcustomdocumentid_;
}
inline ::std::string* StructuredDataAttachment::release_parentcustomdocumentid() {
  clear_has_parentcustomdocumentid();
  if (parentcustomdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentcustomdocumentid_;
    parentcustomdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StructuredDataAttachment::set_allocated_parentcustomdocumentid(::std::string* parentcustomdocumentid) {
  if (parentcustomdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete parentcustomdocumentid_;
  }
  if (parentcustomdocumentid) {
    set_has_parentcustomdocumentid();
    parentcustomdocumentid_ = parentcustomdocumentid;
  } else {
    clear_has_parentcustomdocumentid();
    parentcustomdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PriceListAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool PriceListAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceListAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceListAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceListAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& PriceListAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* PriceListAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* PriceListAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void PriceListAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool PriceListAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceListAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceListAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceListAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& PriceListAttachment::filename() const {
  return *filename_;
}
inline void PriceListAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PriceListAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PriceListAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* PriceListAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool PriceListAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PriceListAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PriceListAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PriceListAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& PriceListAttachment::comment() const {
  return *comment_;
}
inline void PriceListAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void PriceListAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void PriceListAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* PriceListAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
inline int PriceListAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void PriceListAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& PriceListAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* PriceListAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* PriceListAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
PriceListAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
PriceListAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
inline int PriceListAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void PriceListAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& PriceListAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* PriceListAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* PriceListAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
PriceListAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
PriceListAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool PriceListAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PriceListAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PriceListAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PriceListAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& PriceListAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void PriceListAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void PriceListAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void PriceListAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* PriceListAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentDate = 7;
inline bool PriceListAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PriceListAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PriceListAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PriceListAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& PriceListAttachment::documentdate() const {
  return *documentdate_;
}
inline void PriceListAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void PriceListAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void PriceListAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* PriceListAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 8;
inline bool PriceListAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PriceListAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PriceListAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PriceListAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& PriceListAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void PriceListAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void PriceListAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void PriceListAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* PriceListAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string PriceListEffectiveDate = 9;
inline bool PriceListAttachment::has_pricelisteffectivedate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PriceListAttachment::set_has_pricelisteffectivedate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PriceListAttachment::clear_has_pricelisteffectivedate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PriceListAttachment::clear_pricelisteffectivedate() {
  if (pricelisteffectivedate_ != &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_->clear();
  }
  clear_has_pricelisteffectivedate();
}
inline const ::std::string& PriceListAttachment::pricelisteffectivedate() const {
  return *pricelisteffectivedate_;
}
inline void PriceListAttachment::set_pricelisteffectivedate(const ::std::string& value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
}
inline void PriceListAttachment::set_pricelisteffectivedate(const char* value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
}
inline void PriceListAttachment::set_pricelisteffectivedate(const char* value, size_t size) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_pricelisteffectivedate() {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  return pricelisteffectivedate_;
}
inline ::std::string* PriceListAttachment::release_pricelisteffectivedate() {
  clear_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pricelisteffectivedate_;
    pricelisteffectivedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_pricelisteffectivedate(::std::string* pricelisteffectivedate) {
  if (pricelisteffectivedate_ != &::google::protobuf::internal::kEmptyString) {
    delete pricelisteffectivedate_;
  }
  if (pricelisteffectivedate) {
    set_has_pricelisteffectivedate();
    pricelisteffectivedate_ = pricelisteffectivedate;
  } else {
    clear_has_pricelisteffectivedate();
    pricelisteffectivedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ContractDocumentDate = 10;
inline bool PriceListAttachment::has_contractdocumentdate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PriceListAttachment::set_has_contractdocumentdate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PriceListAttachment::clear_has_contractdocumentdate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PriceListAttachment::clear_contractdocumentdate() {
  if (contractdocumentdate_ != &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_->clear();
  }
  clear_has_contractdocumentdate();
}
inline const ::std::string& PriceListAttachment::contractdocumentdate() const {
  return *contractdocumentdate_;
}
inline void PriceListAttachment::set_contractdocumentdate(const ::std::string& value) {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  contractdocumentdate_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentdate(const char* value) {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  contractdocumentdate_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentdate(const char* value, size_t size) {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  contractdocumentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_contractdocumentdate() {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  return contractdocumentdate_;
}
inline ::std::string* PriceListAttachment::release_contractdocumentdate() {
  clear_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractdocumentdate_;
    contractdocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_contractdocumentdate(::std::string* contractdocumentdate) {
  if (contractdocumentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete contractdocumentdate_;
  }
  if (contractdocumentdate) {
    set_has_contractdocumentdate();
    contractdocumentdate_ = contractdocumentdate;
  } else {
    clear_has_contractdocumentdate();
    contractdocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ContractDocumentNumber = 11;
inline bool PriceListAttachment::has_contractdocumentnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PriceListAttachment::set_has_contractdocumentnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PriceListAttachment::clear_has_contractdocumentnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PriceListAttachment::clear_contractdocumentnumber() {
  if (contractdocumentnumber_ != &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_->clear();
  }
  clear_has_contractdocumentnumber();
}
inline const ::std::string& PriceListAttachment::contractdocumentnumber() const {
  return *contractdocumentnumber_;
}
inline void PriceListAttachment::set_contractdocumentnumber(const ::std::string& value) {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  contractdocumentnumber_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentnumber(const char* value) {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  contractdocumentnumber_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentnumber(const char* value, size_t size) {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  contractdocumentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_contractdocumentnumber() {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  return contractdocumentnumber_;
}
inline ::std::string* PriceListAttachment::release_contractdocumentnumber() {
  clear_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractdocumentnumber_;
    contractdocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_contractdocumentnumber(::std::string* contractdocumentnumber) {
  if (contractdocumentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete contractdocumentnumber_;
  }
  if (contractdocumentnumber) {
    set_has_contractdocumentnumber();
    contractdocumentnumber_ = contractdocumentnumber;
  } else {
    clear_has_contractdocumentnumber();
    contractdocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 12 [default = false];
inline bool PriceListAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PriceListAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PriceListAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PriceListAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool PriceListAttachment::needreceipt() const {
  return needreceipt_;
}
inline void PriceListAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// ReconciliationActAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool ReconciliationActAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconciliationActAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconciliationActAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconciliationActAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& ReconciliationActAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ReconciliationActAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ReconciliationActAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void ReconciliationActAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool ReconciliationActAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReconciliationActAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReconciliationActAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReconciliationActAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ReconciliationActAttachment::filename() const {
  return *filename_;
}
inline void ReconciliationActAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ReconciliationActAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ReconciliationActAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ReconciliationActAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool ReconciliationActAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReconciliationActAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReconciliationActAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReconciliationActAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ReconciliationActAttachment::comment() const {
  return *comment_;
}
inline void ReconciliationActAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ReconciliationActAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ReconciliationActAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ReconciliationActAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 5;
inline int ReconciliationActAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void ReconciliationActAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& ReconciliationActAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ReconciliationActAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ReconciliationActAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
ReconciliationActAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
ReconciliationActAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 6;
inline int ReconciliationActAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void ReconciliationActAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& ReconciliationActAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ReconciliationActAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ReconciliationActAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
ReconciliationActAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
ReconciliationActAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// required string DocumentDate = 7;
inline bool ReconciliationActAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReconciliationActAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReconciliationActAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReconciliationActAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& ReconciliationActAttachment::documentdate() const {
  return *documentdate_;
}
inline void ReconciliationActAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ReconciliationActAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ReconciliationActAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* ReconciliationActAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 8;
inline bool ReconciliationActAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReconciliationActAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReconciliationActAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReconciliationActAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& ReconciliationActAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void ReconciliationActAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ReconciliationActAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ReconciliationActAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* ReconciliationActAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool ReconciliationActAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReconciliationActAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReconciliationActAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReconciliationActAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& ReconciliationActAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void ReconciliationActAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ReconciliationActAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ReconciliationActAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* ReconciliationActAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 10 [default = false];
inline bool ReconciliationActAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReconciliationActAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReconciliationActAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReconciliationActAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool ReconciliationActAttachment::needreceipt() const {
  return needreceipt_;
}
inline void ReconciliationActAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// ContractAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool ContractAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContractAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContractAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContractAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& ContractAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ContractAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ContractAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void ContractAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool ContractAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContractAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContractAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContractAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ContractAttachment::filename() const {
  return *filename_;
}
inline void ContractAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ContractAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ContractAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ContractAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool ContractAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContractAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContractAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContractAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ContractAttachment::comment() const {
  return *comment_;
}
inline void ContractAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ContractAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ContractAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ContractAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 4;
inline int ContractAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void ContractAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& ContractAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ContractAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ContractAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
ContractAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
ContractAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 5;
inline int ContractAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void ContractAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& ContractAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ContractAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ContractAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
ContractAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
ContractAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool ContractAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContractAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContractAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContractAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& ContractAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void ContractAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ContractAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ContractAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* ContractAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentDate = 7;
inline bool ContractAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContractAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContractAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContractAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& ContractAttachment::documentdate() const {
  return *documentdate_;
}
inline void ContractAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ContractAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ContractAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* ContractAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 8;
inline bool ContractAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContractAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContractAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContractAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& ContractAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void ContractAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ContractAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ContractAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* ContractAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ContractPrice = 9;
inline bool ContractAttachment::has_contractprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContractAttachment::set_has_contractprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContractAttachment::clear_has_contractprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContractAttachment::clear_contractprice() {
  if (contractprice_ != &::google::protobuf::internal::kEmptyString) {
    contractprice_->clear();
  }
  clear_has_contractprice();
}
inline const ::std::string& ContractAttachment::contractprice() const {
  return *contractprice_;
}
inline void ContractAttachment::set_contractprice(const ::std::string& value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
}
inline void ContractAttachment::set_contractprice(const char* value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
}
inline void ContractAttachment::set_contractprice(const char* value, size_t size) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_contractprice() {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  return contractprice_;
}
inline ::std::string* ContractAttachment::release_contractprice() {
  clear_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractprice_;
    contractprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_contractprice(::std::string* contractprice) {
  if (contractprice_ != &::google::protobuf::internal::kEmptyString) {
    delete contractprice_;
  }
  if (contractprice) {
    set_has_contractprice();
    contractprice_ = contractprice;
  } else {
    clear_has_contractprice();
    contractprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ContractType = 10;
inline bool ContractAttachment::has_contracttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContractAttachment::set_has_contracttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContractAttachment::clear_has_contracttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ContractAttachment::clear_contracttype() {
  if (contracttype_ != &::google::protobuf::internal::kEmptyString) {
    contracttype_->clear();
  }
  clear_has_contracttype();
}
inline const ::std::string& ContractAttachment::contracttype() const {
  return *contracttype_;
}
inline void ContractAttachment::set_contracttype(const ::std::string& value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void ContractAttachment::set_contracttype(const char* value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void ContractAttachment::set_contracttype(const char* value, size_t size) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_contracttype() {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  return contracttype_;
}
inline ::std::string* ContractAttachment::release_contracttype() {
  clear_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contracttype_;
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_contracttype(::std::string* contracttype) {
  if (contracttype_ != &::google::protobuf::internal::kEmptyString) {
    delete contracttype_;
  }
  if (contracttype) {
    set_has_contracttype();
    contracttype_ = contracttype;
  } else {
    clear_has_contracttype();
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 11 [default = false];
inline bool ContractAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ContractAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ContractAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ContractAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool ContractAttachment::needreceipt() const {
  return needreceipt_;
}
inline void ContractAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// ServiceDetailsAttachment

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 1;
inline bool ServiceDetailsAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceDetailsAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceDetailsAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceDetailsAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& ServiceDetailsAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ServiceDetailsAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ServiceDetailsAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void ServiceDetailsAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool ServiceDetailsAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceDetailsAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceDetailsAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceDetailsAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ServiceDetailsAttachment::filename() const {
  return *filename_;
}
inline void ServiceDetailsAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ServiceDetailsAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ServiceDetailsAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ServiceDetailsAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool ServiceDetailsAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceDetailsAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceDetailsAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceDetailsAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ServiceDetailsAttachment::comment() const {
  return *comment_;
}
inline void ServiceDetailsAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ServiceDetailsAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ServiceDetailsAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ServiceDetailsAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.DocumentId InitialDocumentIds = 5;
inline int ServiceDetailsAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void ServiceDetailsAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& ServiceDetailsAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ServiceDetailsAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ServiceDetailsAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
ServiceDetailsAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
ServiceDetailsAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .Diadoc.Api.Proto.DocumentId SubordinateDocumentIds = 6;
inline int ServiceDetailsAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void ServiceDetailsAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::Diadoc::Api::Proto::DocumentId& ServiceDetailsAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ServiceDetailsAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::Diadoc::Api::Proto::DocumentId* ServiceDetailsAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >&
ServiceDetailsAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::DocumentId >*
ServiceDetailsAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string DocumentDate = 7;
inline bool ServiceDetailsAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceDetailsAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceDetailsAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceDetailsAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& ServiceDetailsAttachment::documentdate() const {
  return *documentdate_;
}
inline void ServiceDetailsAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* ServiceDetailsAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DocumentNumber = 8;
inline bool ServiceDetailsAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServiceDetailsAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServiceDetailsAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServiceDetailsAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& ServiceDetailsAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void ServiceDetailsAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* ServiceDetailsAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool ServiceDetailsAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServiceDetailsAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServiceDetailsAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServiceDetailsAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& ServiceDetailsAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void ServiceDetailsAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ServiceDetailsAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ServiceDetailsAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* ServiceDetailsAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 10 [default = false];
inline bool ServiceDetailsAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServiceDetailsAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServiceDetailsAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServiceDetailsAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool ServiceDetailsAttachment::needreceipt() const {
  return needreceipt_;
}
inline void ServiceDetailsAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// MessagePatchToPost

// required string BoxId = 1;
inline bool MessagePatchToPost::has_boxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessagePatchToPost::set_has_boxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessagePatchToPost::clear_has_boxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessagePatchToPost::clear_boxid() {
  if (boxid_ != &::google::protobuf::internal::kEmptyString) {
    boxid_->clear();
  }
  clear_has_boxid();
}
inline const ::std::string& MessagePatchToPost::boxid() const {
  return *boxid_;
}
inline void MessagePatchToPost::set_boxid(const ::std::string& value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
}
inline void MessagePatchToPost::set_boxid(const char* value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
}
inline void MessagePatchToPost::set_boxid(const char* value, size_t size) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePatchToPost::mutable_boxid() {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  return boxid_;
}
inline ::std::string* MessagePatchToPost::release_boxid() {
  clear_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = boxid_;
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessagePatchToPost::set_allocated_boxid(::std::string* boxid) {
  if (boxid_ != &::google::protobuf::internal::kEmptyString) {
    delete boxid_;
  }
  if (boxid) {
    set_has_boxid();
    boxid_ = boxid;
  } else {
    clear_has_boxid();
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MessageId = 2;
inline bool MessagePatchToPost::has_messageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessagePatchToPost::set_has_messageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessagePatchToPost::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessagePatchToPost::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& MessagePatchToPost::messageid() const {
  return *messageid_;
}
inline void MessagePatchToPost::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void MessagePatchToPost::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void MessagePatchToPost::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePatchToPost::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* MessagePatchToPost::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessagePatchToPost::set_allocated_messageid(::std::string* messageid) {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    delete messageid_;
  }
  if (messageid) {
    set_has_messageid();
    messageid_ = messageid;
  } else {
    clear_has_messageid();
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.Events.ReceiptAttachment Receipts = 3;
inline int MessagePatchToPost::receipts_size() const {
  return receipts_.size();
}
inline void MessagePatchToPost::clear_receipts() {
  receipts_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ReceiptAttachment& MessagePatchToPost::receipts(int index) const {
  return receipts_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* MessagePatchToPost::mutable_receipts(int index) {
  return receipts_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* MessagePatchToPost::add_receipts() {
  return receipts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >&
MessagePatchToPost::receipts() const {
  return receipts_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >*
MessagePatchToPost::mutable_receipts() {
  return &receipts_;
}

// repeated .Diadoc.Api.Proto.Events.CorrectionRequestAttachment CorrectionRequests = 4;
inline int MessagePatchToPost::correctionrequests_size() const {
  return correctionrequests_.size();
}
inline void MessagePatchToPost::clear_correctionrequests() {
  correctionrequests_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment& MessagePatchToPost::correctionrequests(int index) const {
  return correctionrequests_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment* MessagePatchToPost::mutable_correctionrequests(int index) {
  return correctionrequests_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment* MessagePatchToPost::add_correctionrequests() {
  return correctionrequests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment >&
MessagePatchToPost::correctionrequests() const {
  return correctionrequests_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::CorrectionRequestAttachment >*
MessagePatchToPost::mutable_correctionrequests() {
  return &correctionrequests_;
}

// repeated .Diadoc.Api.Proto.Events.DocumentSignature RequestedSignatures = 5;
inline int MessagePatchToPost::requestedsignatures_size() const {
  return requestedsignatures_.size();
}
inline void MessagePatchToPost::clear_requestedsignatures() {
  requestedsignatures_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::DocumentSignature& MessagePatchToPost::requestedsignatures(int index) const {
  return requestedsignatures_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::DocumentSignature* MessagePatchToPost::mutable_requestedsignatures(int index) {
  return requestedsignatures_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::DocumentSignature* MessagePatchToPost::add_requestedsignatures() {
  return requestedsignatures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >&
MessagePatchToPost::requestedsignatures() const {
  return requestedsignatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >*
MessagePatchToPost::mutable_requestedsignatures() {
  return &requestedsignatures_;
}

// repeated .Diadoc.Api.Proto.Events.RequestedSignatureRejection RequestedSignatureRejections = 6;
inline int MessagePatchToPost::requestedsignaturerejections_size() const {
  return requestedsignaturerejections_.size();
}
inline void MessagePatchToPost::clear_requestedsignaturerejections() {
  requestedsignaturerejections_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::RequestedSignatureRejection& MessagePatchToPost::requestedsignaturerejections(int index) const {
  return requestedsignaturerejections_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::RequestedSignatureRejection* MessagePatchToPost::mutable_requestedsignaturerejections(int index) {
  return requestedsignaturerejections_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::RequestedSignatureRejection* MessagePatchToPost::add_requestedsignaturerejections() {
  return requestedsignaturerejections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RequestedSignatureRejection >&
MessagePatchToPost::requestedsignaturerejections() const {
  return requestedsignaturerejections_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RequestedSignatureRejection >*
MessagePatchToPost::mutable_requestedsignaturerejections() {
  return &requestedsignaturerejections_;
}

// repeated .Diadoc.Api.Proto.Events.ReceiptAttachment XmlTorg12BuyerTitles = 7;
inline int MessagePatchToPost::xmltorg12buyertitles_size() const {
  return xmltorg12buyertitles_.size();
}
inline void MessagePatchToPost::clear_xmltorg12buyertitles() {
  xmltorg12buyertitles_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ReceiptAttachment& MessagePatchToPost::xmltorg12buyertitles(int index) const {
  return xmltorg12buyertitles_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* MessagePatchToPost::mutable_xmltorg12buyertitles(int index) {
  return xmltorg12buyertitles_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* MessagePatchToPost::add_xmltorg12buyertitles() {
  return xmltorg12buyertitles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >&
MessagePatchToPost::xmltorg12buyertitles() const {
  return xmltorg12buyertitles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >*
MessagePatchToPost::mutable_xmltorg12buyertitles() {
  return &xmltorg12buyertitles_;
}

// repeated .Diadoc.Api.Proto.Events.ReceiptAttachment XmlAcceptanceCertificateBuyerTitles = 8;
inline int MessagePatchToPost::xmlacceptancecertificatebuyertitles_size() const {
  return xmlacceptancecertificatebuyertitles_.size();
}
inline void MessagePatchToPost::clear_xmlacceptancecertificatebuyertitles() {
  xmlacceptancecertificatebuyertitles_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ReceiptAttachment& MessagePatchToPost::xmlacceptancecertificatebuyertitles(int index) const {
  return xmlacceptancecertificatebuyertitles_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* MessagePatchToPost::mutable_xmlacceptancecertificatebuyertitles(int index) {
  return xmlacceptancecertificatebuyertitles_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ReceiptAttachment* MessagePatchToPost::add_xmlacceptancecertificatebuyertitles() {
  return xmlacceptancecertificatebuyertitles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >&
MessagePatchToPost::xmlacceptancecertificatebuyertitles() const {
  return xmlacceptancecertificatebuyertitles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ReceiptAttachment >*
MessagePatchToPost::mutable_xmlacceptancecertificatebuyertitles() {
  return &xmlacceptancecertificatebuyertitles_;
}

// repeated .Diadoc.Api.Proto.Events.ResolutionAttachment Resolutions = 9;
inline int MessagePatchToPost::resolutions_size() const {
  return resolutions_.size();
}
inline void MessagePatchToPost::clear_resolutions() {
  resolutions_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionAttachment& MessagePatchToPost::resolutions(int index) const {
  return resolutions_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionAttachment* MessagePatchToPost::mutable_resolutions(int index) {
  return resolutions_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionAttachment* MessagePatchToPost::add_resolutions() {
  return resolutions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionAttachment >&
MessagePatchToPost::resolutions() const {
  return resolutions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionAttachment >*
MessagePatchToPost::mutable_resolutions() {
  return &resolutions_;
}

// repeated .Diadoc.Api.Proto.Events.ResolutionRequestAttachment ResolutionRequests = 10;
inline int MessagePatchToPost::resolutionrequests_size() const {
  return resolutionrequests_.size();
}
inline void MessagePatchToPost::clear_resolutionrequests() {
  resolutionrequests_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment& MessagePatchToPost::resolutionrequests(int index) const {
  return resolutionrequests_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment* MessagePatchToPost::mutable_resolutionrequests(int index) {
  return resolutionrequests_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment* MessagePatchToPost::add_resolutionrequests() {
  return resolutionrequests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment >&
MessagePatchToPost::resolutionrequests() const {
  return resolutionrequests_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestAttachment >*
MessagePatchToPost::mutable_resolutionrequests() {
  return &resolutionrequests_;
}

// repeated .Diadoc.Api.Proto.Events.ResolutionRequestCancellationAttachment ResolutionRequestCancellations = 11;
inline int MessagePatchToPost::resolutionrequestcancellations_size() const {
  return resolutionrequestcancellations_.size();
}
inline void MessagePatchToPost::clear_resolutionrequestcancellations() {
  resolutionrequestcancellations_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment& MessagePatchToPost::resolutionrequestcancellations(int index) const {
  return resolutionrequestcancellations_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment* MessagePatchToPost::mutable_resolutionrequestcancellations(int index) {
  return resolutionrequestcancellations_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment* MessagePatchToPost::add_resolutionrequestcancellations() {
  return resolutionrequestcancellations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment >&
MessagePatchToPost::resolutionrequestcancellations() const {
  return resolutionrequestcancellations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestCancellationAttachment >*
MessagePatchToPost::mutable_resolutionrequestcancellations() {
  return &resolutionrequestcancellations_;
}

// repeated .Diadoc.Api.Proto.Events.ResolutionRequestDenialAttachment ResolutionRequestDenials = 12;
inline int MessagePatchToPost::resolutionrequestdenials_size() const {
  return resolutionrequestdenials_.size();
}
inline void MessagePatchToPost::clear_resolutionrequestdenials() {
  resolutionrequestdenials_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment& MessagePatchToPost::resolutionrequestdenials(int index) const {
  return resolutionrequestdenials_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment* MessagePatchToPost::mutable_resolutionrequestdenials(int index) {
  return resolutionrequestdenials_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment* MessagePatchToPost::add_resolutionrequestdenials() {
  return resolutionrequestdenials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment >&
MessagePatchToPost::resolutionrequestdenials() const {
  return resolutionrequestdenials_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialAttachment >*
MessagePatchToPost::mutable_resolutionrequestdenials() {
  return &resolutionrequestdenials_;
}

// repeated .Diadoc.Api.Proto.Events.ResolutionRequestDenialCancellationAttachment ResolutionRequestDenialCancellations = 13;
inline int MessagePatchToPost::resolutionrequestdenialcancellations_size() const {
  return resolutionrequestdenialcancellations_.size();
}
inline void MessagePatchToPost::clear_resolutionrequestdenialcancellations() {
  resolutionrequestdenialcancellations_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment& MessagePatchToPost::resolutionrequestdenialcancellations(int index) const {
  return resolutionrequestdenialcancellations_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment* MessagePatchToPost::mutable_resolutionrequestdenialcancellations(int index) {
  return resolutionrequestdenialcancellations_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment* MessagePatchToPost::add_resolutionrequestdenialcancellations() {
  return resolutionrequestdenialcancellations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment >&
MessagePatchToPost::resolutionrequestdenialcancellations() const {
  return resolutionrequestdenialcancellations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::ResolutionRequestDenialCancellationAttachment >*
MessagePatchToPost::mutable_resolutionrequestdenialcancellations() {
  return &resolutionrequestdenialcancellations_;
}

// repeated .Diadoc.Api.Proto.Events.RevocationRequestAttachment RevocationRequests = 14;
inline int MessagePatchToPost::revocationrequests_size() const {
  return revocationrequests_.size();
}
inline void MessagePatchToPost::clear_revocationrequests() {
  revocationrequests_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::RevocationRequestAttachment& MessagePatchToPost::revocationrequests(int index) const {
  return revocationrequests_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::RevocationRequestAttachment* MessagePatchToPost::mutable_revocationrequests(int index) {
  return revocationrequests_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::RevocationRequestAttachment* MessagePatchToPost::add_revocationrequests() {
  return revocationrequests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RevocationRequestAttachment >&
MessagePatchToPost::revocationrequests() const {
  return revocationrequests_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::RevocationRequestAttachment >*
MessagePatchToPost::mutable_revocationrequests() {
  return &revocationrequests_;
}

// repeated .Diadoc.Api.Proto.Events.XmlSignatureRejectionAttachment XmlSignatureRejections = 15;
inline int MessagePatchToPost::xmlsignaturerejections_size() const {
  return xmlsignaturerejections_.size();
}
inline void MessagePatchToPost::clear_xmlsignaturerejections() {
  xmlsignaturerejections_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment& MessagePatchToPost::xmlsignaturerejections(int index) const {
  return xmlsignaturerejections_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment* MessagePatchToPost::mutable_xmlsignaturerejections(int index) {
  return xmlsignaturerejections_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment* MessagePatchToPost::add_xmlsignaturerejections() {
  return xmlsignaturerejections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment >&
MessagePatchToPost::xmlsignaturerejections() const {
  return xmlsignaturerejections_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::XmlSignatureRejectionAttachment >*
MessagePatchToPost::mutable_xmlsignaturerejections() {
  return &xmlsignaturerejections_;
}

// -------------------------------------------------------------------

// ResolutionRequestAttachment

// required string InitialDocumentId = 1;
inline bool ResolutionRequestAttachment::has_initialdocumentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolutionRequestAttachment::set_has_initialdocumentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolutionRequestAttachment::clear_has_initialdocumentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolutionRequestAttachment::clear_initialdocumentid() {
  if (initialdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_->clear();
  }
  clear_has_initialdocumentid();
}
inline const ::std::string& ResolutionRequestAttachment::initialdocumentid() const {
  return *initialdocumentid_;
}
inline void ResolutionRequestAttachment::set_initialdocumentid(const ::std::string& value) {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  initialdocumentid_->assign(value);
}
inline void ResolutionRequestAttachment::set_initialdocumentid(const char* value) {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  initialdocumentid_->assign(value);
}
inline void ResolutionRequestAttachment::set_initialdocumentid(const char* value, size_t size) {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  initialdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestAttachment::mutable_initialdocumentid() {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  return initialdocumentid_;
}
inline ::std::string* ResolutionRequestAttachment::release_initialdocumentid() {
  clear_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initialdocumentid_;
    initialdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestAttachment::set_allocated_initialdocumentid(::std::string* initialdocumentid) {
  if (initialdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete initialdocumentid_;
  }
  if (initialdocumentid) {
    set_has_initialdocumentid();
    initialdocumentid_ = initialdocumentid;
  } else {
    clear_has_initialdocumentid();
    initialdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Diadoc.Api.Proto.Events.ResolutionRequestType Type = 2;
inline bool ResolutionRequestAttachment::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResolutionRequestAttachment::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResolutionRequestAttachment::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResolutionRequestAttachment::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestType ResolutionRequestAttachment::type() const {
  return static_cast< ::Diadoc::Api::Proto::Events::ResolutionRequestType >(type_);
}
inline void ResolutionRequestAttachment::set_type(::Diadoc::Api::Proto::Events::ResolutionRequestType value) {
  assert(::Diadoc::Api::Proto::Events::ResolutionRequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string TargetUserId = 3;
inline bool ResolutionRequestAttachment::has_targetuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResolutionRequestAttachment::set_has_targetuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResolutionRequestAttachment::clear_has_targetuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResolutionRequestAttachment::clear_targetuserid() {
  if (targetuserid_ != &::google::protobuf::internal::kEmptyString) {
    targetuserid_->clear();
  }
  clear_has_targetuserid();
}
inline const ::std::string& ResolutionRequestAttachment::targetuserid() const {
  return *targetuserid_;
}
inline void ResolutionRequestAttachment::set_targetuserid(const ::std::string& value) {
  set_has_targetuserid();
  if (targetuserid_ == &::google::protobuf::internal::kEmptyString) {
    targetuserid_ = new ::std::string;
  }
  targetuserid_->assign(value);
}
inline void ResolutionRequestAttachment::set_targetuserid(const char* value) {
  set_has_targetuserid();
  if (targetuserid_ == &::google::protobuf::internal::kEmptyString) {
    targetuserid_ = new ::std::string;
  }
  targetuserid_->assign(value);
}
inline void ResolutionRequestAttachment::set_targetuserid(const char* value, size_t size) {
  set_has_targetuserid();
  if (targetuserid_ == &::google::protobuf::internal::kEmptyString) {
    targetuserid_ = new ::std::string;
  }
  targetuserid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestAttachment::mutable_targetuserid() {
  set_has_targetuserid();
  if (targetuserid_ == &::google::protobuf::internal::kEmptyString) {
    targetuserid_ = new ::std::string;
  }
  return targetuserid_;
}
inline ::std::string* ResolutionRequestAttachment::release_targetuserid() {
  clear_has_targetuserid();
  if (targetuserid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetuserid_;
    targetuserid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestAttachment::set_allocated_targetuserid(::std::string* targetuserid) {
  if (targetuserid_ != &::google::protobuf::internal::kEmptyString) {
    delete targetuserid_;
  }
  if (targetuserid) {
    set_has_targetuserid();
    targetuserid_ = targetuserid;
  } else {
    clear_has_targetuserid();
    targetuserid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string TargetDepartmentId = 4;
inline bool ResolutionRequestAttachment::has_targetdepartmentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResolutionRequestAttachment::set_has_targetdepartmentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResolutionRequestAttachment::clear_has_targetdepartmentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResolutionRequestAttachment::clear_targetdepartmentid() {
  if (targetdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    targetdepartmentid_->clear();
  }
  clear_has_targetdepartmentid();
}
inline const ::std::string& ResolutionRequestAttachment::targetdepartmentid() const {
  return *targetdepartmentid_;
}
inline void ResolutionRequestAttachment::set_targetdepartmentid(const ::std::string& value) {
  set_has_targetdepartmentid();
  if (targetdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    targetdepartmentid_ = new ::std::string;
  }
  targetdepartmentid_->assign(value);
}
inline void ResolutionRequestAttachment::set_targetdepartmentid(const char* value) {
  set_has_targetdepartmentid();
  if (targetdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    targetdepartmentid_ = new ::std::string;
  }
  targetdepartmentid_->assign(value);
}
inline void ResolutionRequestAttachment::set_targetdepartmentid(const char* value, size_t size) {
  set_has_targetdepartmentid();
  if (targetdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    targetdepartmentid_ = new ::std::string;
  }
  targetdepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestAttachment::mutable_targetdepartmentid() {
  set_has_targetdepartmentid();
  if (targetdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    targetdepartmentid_ = new ::std::string;
  }
  return targetdepartmentid_;
}
inline ::std::string* ResolutionRequestAttachment::release_targetdepartmentid() {
  clear_has_targetdepartmentid();
  if (targetdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = targetdepartmentid_;
    targetdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestAttachment::set_allocated_targetdepartmentid(::std::string* targetdepartmentid) {
  if (targetdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete targetdepartmentid_;
  }
  if (targetdepartmentid) {
    set_has_targetdepartmentid();
    targetdepartmentid_ = targetdepartmentid;
  } else {
    clear_has_targetdepartmentid();
    targetdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 5;
inline bool ResolutionRequestAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResolutionRequestAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResolutionRequestAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResolutionRequestAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ResolutionRequestAttachment::comment() const {
  return *comment_;
}
inline void ResolutionRequestAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ResolutionRequestAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ResolutionRequestAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ResolutionRequestAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResolutionRequestCancellationAttachment

// required string InitialResolutionRequestId = 1;
inline bool ResolutionRequestCancellationAttachment::has_initialresolutionrequestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolutionRequestCancellationAttachment::set_has_initialresolutionrequestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolutionRequestCancellationAttachment::clear_has_initialresolutionrequestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolutionRequestCancellationAttachment::clear_initialresolutionrequestid() {
  if (initialresolutionrequestid_ != &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_->clear();
  }
  clear_has_initialresolutionrequestid();
}
inline const ::std::string& ResolutionRequestCancellationAttachment::initialresolutionrequestid() const {
  return *initialresolutionrequestid_;
}
inline void ResolutionRequestCancellationAttachment::set_initialresolutionrequestid(const ::std::string& value) {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  initialresolutionrequestid_->assign(value);
}
inline void ResolutionRequestCancellationAttachment::set_initialresolutionrequestid(const char* value) {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  initialresolutionrequestid_->assign(value);
}
inline void ResolutionRequestCancellationAttachment::set_initialresolutionrequestid(const char* value, size_t size) {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  initialresolutionrequestid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestCancellationAttachment::mutable_initialresolutionrequestid() {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  return initialresolutionrequestid_;
}
inline ::std::string* ResolutionRequestCancellationAttachment::release_initialresolutionrequestid() {
  clear_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initialresolutionrequestid_;
    initialresolutionrequestid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestCancellationAttachment::set_allocated_initialresolutionrequestid(::std::string* initialresolutionrequestid) {
  if (initialresolutionrequestid_ != &::google::protobuf::internal::kEmptyString) {
    delete initialresolutionrequestid_;
  }
  if (initialresolutionrequestid) {
    set_has_initialresolutionrequestid();
    initialresolutionrequestid_ = initialresolutionrequestid;
  } else {
    clear_has_initialresolutionrequestid();
    initialresolutionrequestid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResolutionRequestDenialCancellationAttachment

// required string InitialResolutionRequestDenialId = 1;
inline bool ResolutionRequestDenialCancellationAttachment::has_initialresolutionrequestdenialid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolutionRequestDenialCancellationAttachment::set_has_initialresolutionrequestdenialid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolutionRequestDenialCancellationAttachment::clear_has_initialresolutionrequestdenialid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolutionRequestDenialCancellationAttachment::clear_initialresolutionrequestdenialid() {
  if (initialresolutionrequestdenialid_ != &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestdenialid_->clear();
  }
  clear_has_initialresolutionrequestdenialid();
}
inline const ::std::string& ResolutionRequestDenialCancellationAttachment::initialresolutionrequestdenialid() const {
  return *initialresolutionrequestdenialid_;
}
inline void ResolutionRequestDenialCancellationAttachment::set_initialresolutionrequestdenialid(const ::std::string& value) {
  set_has_initialresolutionrequestdenialid();
  if (initialresolutionrequestdenialid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestdenialid_ = new ::std::string;
  }
  initialresolutionrequestdenialid_->assign(value);
}
inline void ResolutionRequestDenialCancellationAttachment::set_initialresolutionrequestdenialid(const char* value) {
  set_has_initialresolutionrequestdenialid();
  if (initialresolutionrequestdenialid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestdenialid_ = new ::std::string;
  }
  initialresolutionrequestdenialid_->assign(value);
}
inline void ResolutionRequestDenialCancellationAttachment::set_initialresolutionrequestdenialid(const char* value, size_t size) {
  set_has_initialresolutionrequestdenialid();
  if (initialresolutionrequestdenialid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestdenialid_ = new ::std::string;
  }
  initialresolutionrequestdenialid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestDenialCancellationAttachment::mutable_initialresolutionrequestdenialid() {
  set_has_initialresolutionrequestdenialid();
  if (initialresolutionrequestdenialid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestdenialid_ = new ::std::string;
  }
  return initialresolutionrequestdenialid_;
}
inline ::std::string* ResolutionRequestDenialCancellationAttachment::release_initialresolutionrequestdenialid() {
  clear_has_initialresolutionrequestdenialid();
  if (initialresolutionrequestdenialid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initialresolutionrequestdenialid_;
    initialresolutionrequestdenialid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestDenialCancellationAttachment::set_allocated_initialresolutionrequestdenialid(::std::string* initialresolutionrequestdenialid) {
  if (initialresolutionrequestdenialid_ != &::google::protobuf::internal::kEmptyString) {
    delete initialresolutionrequestdenialid_;
  }
  if (initialresolutionrequestdenialid) {
    set_has_initialresolutionrequestdenialid();
    initialresolutionrequestdenialid_ = initialresolutionrequestdenialid;
  } else {
    clear_has_initialresolutionrequestdenialid();
    initialresolutionrequestdenialid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResolutionRequestDenialAttachment

// required string InitialResolutionRequestId = 1;
inline bool ResolutionRequestDenialAttachment::has_initialresolutionrequestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolutionRequestDenialAttachment::set_has_initialresolutionrequestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolutionRequestDenialAttachment::clear_has_initialresolutionrequestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolutionRequestDenialAttachment::clear_initialresolutionrequestid() {
  if (initialresolutionrequestid_ != &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_->clear();
  }
  clear_has_initialresolutionrequestid();
}
inline const ::std::string& ResolutionRequestDenialAttachment::initialresolutionrequestid() const {
  return *initialresolutionrequestid_;
}
inline void ResolutionRequestDenialAttachment::set_initialresolutionrequestid(const ::std::string& value) {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  initialresolutionrequestid_->assign(value);
}
inline void ResolutionRequestDenialAttachment::set_initialresolutionrequestid(const char* value) {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  initialresolutionrequestid_->assign(value);
}
inline void ResolutionRequestDenialAttachment::set_initialresolutionrequestid(const char* value, size_t size) {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  initialresolutionrequestid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestDenialAttachment::mutable_initialresolutionrequestid() {
  set_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    initialresolutionrequestid_ = new ::std::string;
  }
  return initialresolutionrequestid_;
}
inline ::std::string* ResolutionRequestDenialAttachment::release_initialresolutionrequestid() {
  clear_has_initialresolutionrequestid();
  if (initialresolutionrequestid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initialresolutionrequestid_;
    initialresolutionrequestid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestDenialAttachment::set_allocated_initialresolutionrequestid(::std::string* initialresolutionrequestid) {
  if (initialresolutionrequestid_ != &::google::protobuf::internal::kEmptyString) {
    delete initialresolutionrequestid_;
  }
  if (initialresolutionrequestid) {
    set_has_initialresolutionrequestid();
    initialresolutionrequestid_ = initialresolutionrequestid;
  } else {
    clear_has_initialresolutionrequestid();
    initialresolutionrequestid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 2;
inline bool ResolutionRequestDenialAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResolutionRequestDenialAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResolutionRequestDenialAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResolutionRequestDenialAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ResolutionRequestDenialAttachment::comment() const {
  return *comment_;
}
inline void ResolutionRequestDenialAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ResolutionRequestDenialAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ResolutionRequestDenialAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionRequestDenialAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ResolutionRequestDenialAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionRequestDenialAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResolutionAttachment

// required string InitialDocumentId = 1;
inline bool ResolutionAttachment::has_initialdocumentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolutionAttachment::set_has_initialdocumentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolutionAttachment::clear_has_initialdocumentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolutionAttachment::clear_initialdocumentid() {
  if (initialdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_->clear();
  }
  clear_has_initialdocumentid();
}
inline const ::std::string& ResolutionAttachment::initialdocumentid() const {
  return *initialdocumentid_;
}
inline void ResolutionAttachment::set_initialdocumentid(const ::std::string& value) {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  initialdocumentid_->assign(value);
}
inline void ResolutionAttachment::set_initialdocumentid(const char* value) {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  initialdocumentid_->assign(value);
}
inline void ResolutionAttachment::set_initialdocumentid(const char* value, size_t size) {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  initialdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionAttachment::mutable_initialdocumentid() {
  set_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    initialdocumentid_ = new ::std::string;
  }
  return initialdocumentid_;
}
inline ::std::string* ResolutionAttachment::release_initialdocumentid() {
  clear_has_initialdocumentid();
  if (initialdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initialdocumentid_;
    initialdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionAttachment::set_allocated_initialdocumentid(::std::string* initialdocumentid) {
  if (initialdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete initialdocumentid_;
  }
  if (initialdocumentid) {
    set_has_initialdocumentid();
    initialdocumentid_ = initialdocumentid;
  } else {
    clear_has_initialdocumentid();
    initialdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Diadoc.Api.Proto.Events.ResolutionType ResolutionType = 2;
inline bool ResolutionAttachment::has_resolutiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResolutionAttachment::set_has_resolutiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResolutionAttachment::clear_has_resolutiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResolutionAttachment::clear_resolutiontype() {
  resolutiontype_ = 0;
  clear_has_resolutiontype();
}
inline ::Diadoc::Api::Proto::Events::ResolutionType ResolutionAttachment::resolutiontype() const {
  return static_cast< ::Diadoc::Api::Proto::Events::ResolutionType >(resolutiontype_);
}
inline void ResolutionAttachment::set_resolutiontype(::Diadoc::Api::Proto::Events::ResolutionType value) {
  assert(::Diadoc::Api::Proto::Events::ResolutionType_IsValid(value));
  set_has_resolutiontype();
  resolutiontype_ = value;
}

// optional string Comment = 3;
inline bool ResolutionAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResolutionAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResolutionAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResolutionAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ResolutionAttachment::comment() const {
  return *comment_;
}
inline void ResolutionAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ResolutionAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ResolutionAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResolutionAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ResolutionAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResolutionAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReceiptAttachment

// required string ParentEntityId = 1;
inline bool ReceiptAttachment::has_parententityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReceiptAttachment::set_has_parententityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReceiptAttachment::clear_has_parententityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReceiptAttachment::clear_parententityid() {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    parententityid_->clear();
  }
  clear_has_parententityid();
}
inline const ::std::string& ReceiptAttachment::parententityid() const {
  return *parententityid_;
}
inline void ReceiptAttachment::set_parententityid(const ::std::string& value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void ReceiptAttachment::set_parententityid(const char* value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void ReceiptAttachment::set_parententityid(const char* value, size_t size) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReceiptAttachment::mutable_parententityid() {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  return parententityid_;
}
inline ::std::string* ReceiptAttachment::release_parententityid() {
  clear_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parententityid_;
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReceiptAttachment::set_allocated_parententityid(::std::string* parententityid) {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    delete parententityid_;
  }
  if (parententityid) {
    set_has_parententityid();
    parententityid_ = parententityid;
  } else {
    clear_has_parententityid();
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
inline bool ReceiptAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReceiptAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReceiptAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReceiptAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& ReceiptAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ReceiptAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* ReceiptAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void ReceiptAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// -------------------------------------------------------------------

// CorrectionRequestAttachment

// required string ParentEntityId = 1;
inline bool CorrectionRequestAttachment::has_parententityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CorrectionRequestAttachment::set_has_parententityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CorrectionRequestAttachment::clear_has_parententityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CorrectionRequestAttachment::clear_parententityid() {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    parententityid_->clear();
  }
  clear_has_parententityid();
}
inline const ::std::string& CorrectionRequestAttachment::parententityid() const {
  return *parententityid_;
}
inline void CorrectionRequestAttachment::set_parententityid(const ::std::string& value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void CorrectionRequestAttachment::set_parententityid(const char* value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void CorrectionRequestAttachment::set_parententityid(const char* value, size_t size) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CorrectionRequestAttachment::mutable_parententityid() {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  return parententityid_;
}
inline ::std::string* CorrectionRequestAttachment::release_parententityid() {
  clear_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parententityid_;
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CorrectionRequestAttachment::set_allocated_parententityid(::std::string* parententityid) {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    delete parententityid_;
  }
  if (parententityid) {
    set_has_parententityid();
    parententityid_ = parententityid;
  } else {
    clear_has_parententityid();
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
inline bool CorrectionRequestAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CorrectionRequestAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CorrectionRequestAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CorrectionRequestAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& CorrectionRequestAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* CorrectionRequestAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* CorrectionRequestAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void CorrectionRequestAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// -------------------------------------------------------------------

// DocumentSignature

// required string ParentEntityId = 1;
inline bool DocumentSignature::has_parententityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentSignature::set_has_parententityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentSignature::clear_has_parententityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentSignature::clear_parententityid() {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    parententityid_->clear();
  }
  clear_has_parententityid();
}
inline const ::std::string& DocumentSignature::parententityid() const {
  return *parententityid_;
}
inline void DocumentSignature::set_parententityid(const ::std::string& value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void DocumentSignature::set_parententityid(const char* value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void DocumentSignature::set_parententityid(const char* value, size_t size) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentSignature::mutable_parententityid() {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  return parententityid_;
}
inline ::std::string* DocumentSignature::release_parententityid() {
  clear_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parententityid_;
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DocumentSignature::set_allocated_parententityid(::std::string* parententityid) {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    delete parententityid_;
  }
  if (parententityid) {
    set_has_parententityid();
    parententityid_ = parententityid;
  } else {
    clear_has_parententityid();
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes Signature = 2;
inline bool DocumentSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentSignature::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentSignature::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentSignature::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& DocumentSignature::signature() const {
  return *signature_;
}
inline void DocumentSignature::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void DocumentSignature::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void DocumentSignature::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentSignature::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* DocumentSignature::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DocumentSignature::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool SignByAttorney = 3 [default = false];
inline bool DocumentSignature::has_signbyattorney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentSignature::set_has_signbyattorney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentSignature::clear_has_signbyattorney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentSignature::clear_signbyattorney() {
  signbyattorney_ = false;
  clear_has_signbyattorney();
}
inline bool DocumentSignature::signbyattorney() const {
  return signbyattorney_;
}
inline void DocumentSignature::set_signbyattorney(bool value) {
  set_has_signbyattorney();
  signbyattorney_ = value;
}

// optional bool SignWithTestSignature = 4 [default = false];
inline bool DocumentSignature::has_signwithtestsignature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentSignature::set_has_signwithtestsignature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentSignature::clear_has_signwithtestsignature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentSignature::clear_signwithtestsignature() {
  signwithtestsignature_ = false;
  clear_has_signwithtestsignature();
}
inline bool DocumentSignature::signwithtestsignature() const {
  return signwithtestsignature_;
}
inline void DocumentSignature::set_signwithtestsignature(bool value) {
  set_has_signwithtestsignature();
  signwithtestsignature_ = value;
}

// -------------------------------------------------------------------

// RequestedSignatureRejection

// required string ParentEntityId = 1;
inline bool RequestedSignatureRejection::has_parententityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestedSignatureRejection::set_has_parententityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestedSignatureRejection::clear_has_parententityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestedSignatureRejection::clear_parententityid() {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    parententityid_->clear();
  }
  clear_has_parententityid();
}
inline const ::std::string& RequestedSignatureRejection::parententityid() const {
  return *parententityid_;
}
inline void RequestedSignatureRejection::set_parententityid(const ::std::string& value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void RequestedSignatureRejection::set_parententityid(const char* value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void RequestedSignatureRejection::set_parententityid(const char* value, size_t size) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestedSignatureRejection::mutable_parententityid() {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  return parententityid_;
}
inline ::std::string* RequestedSignatureRejection::release_parententityid() {
  clear_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parententityid_;
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestedSignatureRejection::set_allocated_parententityid(::std::string* parententityid) {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    delete parententityid_;
  }
  if (parententityid) {
    set_has_parententityid();
    parententityid_ = parententityid;
  } else {
    clear_has_parententityid();
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
inline bool RequestedSignatureRejection::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestedSignatureRejection::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestedSignatureRejection::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestedSignatureRejection::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& RequestedSignatureRejection::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* RequestedSignatureRejection::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* RequestedSignatureRejection::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void RequestedSignatureRejection::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// -------------------------------------------------------------------

// SignedContent

// optional bytes Content = 1;
inline bool SignedContent::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedContent::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedContent::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedContent::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SignedContent::content() const {
  return *content_;
}
inline void SignedContent::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SignedContent::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SignedContent::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedContent::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* SignedContent::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedContent::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes Signature = 2;
inline bool SignedContent::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedContent::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedContent::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedContent::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedContent::signature() const {
  return *signature_;
}
inline void SignedContent::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedContent::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedContent::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedContent::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedContent::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedContent::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool SignByAttorney = 3 [default = false];
inline bool SignedContent::has_signbyattorney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedContent::set_has_signbyattorney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedContent::clear_has_signbyattorney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedContent::clear_signbyattorney() {
  signbyattorney_ = false;
  clear_has_signbyattorney();
}
inline bool SignedContent::signbyattorney() const {
  return signbyattorney_;
}
inline void SignedContent::set_signbyattorney(bool value) {
  set_has_signbyattorney();
  signbyattorney_ = value;
}

// optional string NameOnShelf = 4;
inline bool SignedContent::has_nameonshelf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedContent::set_has_nameonshelf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedContent::clear_has_nameonshelf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedContent::clear_nameonshelf() {
  if (nameonshelf_ != &::google::protobuf::internal::kEmptyString) {
    nameonshelf_->clear();
  }
  clear_has_nameonshelf();
}
inline const ::std::string& SignedContent::nameonshelf() const {
  return *nameonshelf_;
}
inline void SignedContent::set_nameonshelf(const ::std::string& value) {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  nameonshelf_->assign(value);
}
inline void SignedContent::set_nameonshelf(const char* value) {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  nameonshelf_->assign(value);
}
inline void SignedContent::set_nameonshelf(const char* value, size_t size) {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  nameonshelf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedContent::mutable_nameonshelf() {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  return nameonshelf_;
}
inline ::std::string* SignedContent::release_nameonshelf() {
  clear_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nameonshelf_;
    nameonshelf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedContent::set_allocated_nameonshelf(::std::string* nameonshelf) {
  if (nameonshelf_ != &::google::protobuf::internal::kEmptyString) {
    delete nameonshelf_;
  }
  if (nameonshelf) {
    set_has_nameonshelf();
    nameonshelf_ = nameonshelf;
  } else {
    clear_has_nameonshelf();
    nameonshelf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool SignWithTestSignature = 5 [default = false];
inline bool SignedContent::has_signwithtestsignature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignedContent::set_has_signwithtestsignature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignedContent::clear_has_signwithtestsignature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignedContent::clear_signwithtestsignature() {
  signwithtestsignature_ = false;
  clear_has_signwithtestsignature();
}
inline bool SignedContent::signwithtestsignature() const {
  return signwithtestsignature_;
}
inline void SignedContent::set_signwithtestsignature(bool value) {
  set_has_signwithtestsignature();
  signwithtestsignature_ = value;
}

// -------------------------------------------------------------------

// DraftToSend

// required string BoxId = 1;
inline bool DraftToSend::has_boxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DraftToSend::set_has_boxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DraftToSend::clear_has_boxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DraftToSend::clear_boxid() {
  if (boxid_ != &::google::protobuf::internal::kEmptyString) {
    boxid_->clear();
  }
  clear_has_boxid();
}
inline const ::std::string& DraftToSend::boxid() const {
  return *boxid_;
}
inline void DraftToSend::set_boxid(const ::std::string& value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
}
inline void DraftToSend::set_boxid(const char* value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
}
inline void DraftToSend::set_boxid(const char* value, size_t size) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftToSend::mutable_boxid() {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  return boxid_;
}
inline ::std::string* DraftToSend::release_boxid() {
  clear_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = boxid_;
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DraftToSend::set_allocated_boxid(::std::string* boxid) {
  if (boxid_ != &::google::protobuf::internal::kEmptyString) {
    delete boxid_;
  }
  if (boxid) {
    set_has_boxid();
    boxid_ = boxid;
  } else {
    clear_has_boxid();
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DraftId = 2;
inline bool DraftToSend::has_draftid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DraftToSend::set_has_draftid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DraftToSend::clear_has_draftid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DraftToSend::clear_draftid() {
  if (draftid_ != &::google::protobuf::internal::kEmptyString) {
    draftid_->clear();
  }
  clear_has_draftid();
}
inline const ::std::string& DraftToSend::draftid() const {
  return *draftid_;
}
inline void DraftToSend::set_draftid(const ::std::string& value) {
  set_has_draftid();
  if (draftid_ == &::google::protobuf::internal::kEmptyString) {
    draftid_ = new ::std::string;
  }
  draftid_->assign(value);
}
inline void DraftToSend::set_draftid(const char* value) {
  set_has_draftid();
  if (draftid_ == &::google::protobuf::internal::kEmptyString) {
    draftid_ = new ::std::string;
  }
  draftid_->assign(value);
}
inline void DraftToSend::set_draftid(const char* value, size_t size) {
  set_has_draftid();
  if (draftid_ == &::google::protobuf::internal::kEmptyString) {
    draftid_ = new ::std::string;
  }
  draftid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftToSend::mutable_draftid() {
  set_has_draftid();
  if (draftid_ == &::google::protobuf::internal::kEmptyString) {
    draftid_ = new ::std::string;
  }
  return draftid_;
}
inline ::std::string* DraftToSend::release_draftid() {
  clear_has_draftid();
  if (draftid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = draftid_;
    draftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DraftToSend::set_allocated_draftid(::std::string* draftid) {
  if (draftid_ != &::google::protobuf::internal::kEmptyString) {
    delete draftid_;
  }
  if (draftid) {
    set_has_draftid();
    draftid_ = draftid;
  } else {
    clear_has_draftid();
    draftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ToBoxId = 3;
inline bool DraftToSend::has_toboxid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DraftToSend::set_has_toboxid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DraftToSend::clear_has_toboxid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DraftToSend::clear_toboxid() {
  if (toboxid_ != &::google::protobuf::internal::kEmptyString) {
    toboxid_->clear();
  }
  clear_has_toboxid();
}
inline const ::std::string& DraftToSend::toboxid() const {
  return *toboxid_;
}
inline void DraftToSend::set_toboxid(const ::std::string& value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void DraftToSend::set_toboxid(const char* value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void DraftToSend::set_toboxid(const char* value, size_t size) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftToSend::mutable_toboxid() {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  return toboxid_;
}
inline ::std::string* DraftToSend::release_toboxid() {
  clear_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toboxid_;
    toboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DraftToSend::set_allocated_toboxid(::std::string* toboxid) {
  if (toboxid_ != &::google::protobuf::internal::kEmptyString) {
    delete toboxid_;
  }
  if (toboxid) {
    set_has_toboxid();
    toboxid_ = toboxid;
  } else {
    clear_has_toboxid();
    toboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ToDepartmentId = 4;
inline bool DraftToSend::has_todepartmentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DraftToSend::set_has_todepartmentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DraftToSend::clear_has_todepartmentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DraftToSend::clear_todepartmentid() {
  if (todepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    todepartmentid_->clear();
  }
  clear_has_todepartmentid();
}
inline const ::std::string& DraftToSend::todepartmentid() const {
  return *todepartmentid_;
}
inline void DraftToSend::set_todepartmentid(const ::std::string& value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void DraftToSend::set_todepartmentid(const char* value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void DraftToSend::set_todepartmentid(const char* value, size_t size) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftToSend::mutable_todepartmentid() {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  return todepartmentid_;
}
inline ::std::string* DraftToSend::release_todepartmentid() {
  clear_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todepartmentid_;
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DraftToSend::set_allocated_todepartmentid(::std::string* todepartmentid) {
  if (todepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete todepartmentid_;
  }
  if (todepartmentid) {
    set_has_todepartmentid();
    todepartmentid_ = todepartmentid;
  } else {
    clear_has_todepartmentid();
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.Events.DocumentSignature DocumentSignatures = 5;
inline int DraftToSend::documentsignatures_size() const {
  return documentsignatures_.size();
}
inline void DraftToSend::clear_documentsignatures() {
  documentsignatures_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::DocumentSignature& DraftToSend::documentsignatures(int index) const {
  return documentsignatures_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::DocumentSignature* DraftToSend::mutable_documentsignatures(int index) {
  return documentsignatures_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::DocumentSignature* DraftToSend::add_documentsignatures() {
  return documentsignatures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >&
DraftToSend::documentsignatures() const {
  return documentsignatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >*
DraftToSend::mutable_documentsignatures() {
  return &documentsignatures_;
}

// -------------------------------------------------------------------

// MessageToSend

// required string BoxId = 1;
inline bool MessageToSend::has_boxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageToSend::set_has_boxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageToSend::clear_has_boxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageToSend::clear_boxid() {
  if (boxid_ != &::google::protobuf::internal::kEmptyString) {
    boxid_->clear();
  }
  clear_has_boxid();
}
inline const ::std::string& MessageToSend::boxid() const {
  return *boxid_;
}
inline void MessageToSend::set_boxid(const ::std::string& value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
}
inline void MessageToSend::set_boxid(const char* value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
}
inline void MessageToSend::set_boxid(const char* value, size_t size) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToSend::mutable_boxid() {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    boxid_ = new ::std::string;
  }
  return boxid_;
}
inline ::std::string* MessageToSend::release_boxid() {
  clear_has_boxid();
  if (boxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = boxid_;
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToSend::set_allocated_boxid(::std::string* boxid) {
  if (boxid_ != &::google::protobuf::internal::kEmptyString) {
    delete boxid_;
  }
  if (boxid) {
    set_has_boxid();
    boxid_ = boxid;
  } else {
    clear_has_boxid();
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MessageId = 2;
inline bool MessageToSend::has_messageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageToSend::set_has_messageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageToSend::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageToSend::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& MessageToSend::messageid() const {
  return *messageid_;
}
inline void MessageToSend::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void MessageToSend::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void MessageToSend::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToSend::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* MessageToSend::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToSend::set_allocated_messageid(::std::string* messageid) {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    delete messageid_;
  }
  if (messageid) {
    set_has_messageid();
    messageid_ = messageid;
  } else {
    clear_has_messageid();
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Diadoc.Api.Proto.Events.DocumentSignature DocumentSignatures = 3;
inline int MessageToSend::documentsignatures_size() const {
  return documentsignatures_.size();
}
inline void MessageToSend::clear_documentsignatures() {
  documentsignatures_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::DocumentSignature& MessageToSend::documentsignatures(int index) const {
  return documentsignatures_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::DocumentSignature* MessageToSend::mutable_documentsignatures(int index) {
  return documentsignatures_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::DocumentSignature* MessageToSend::add_documentsignatures() {
  return documentsignatures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >&
MessageToSend::documentsignatures() const {
  return documentsignatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::DocumentSignature >*
MessageToSend::mutable_documentsignatures() {
  return &documentsignatures_;
}

// -------------------------------------------------------------------

// RevocationRequestAttachment

// required string ParentEntityId = 1;
inline bool RevocationRequestAttachment::has_parententityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RevocationRequestAttachment::set_has_parententityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RevocationRequestAttachment::clear_has_parententityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RevocationRequestAttachment::clear_parententityid() {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    parententityid_->clear();
  }
  clear_has_parententityid();
}
inline const ::std::string& RevocationRequestAttachment::parententityid() const {
  return *parententityid_;
}
inline void RevocationRequestAttachment::set_parententityid(const ::std::string& value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void RevocationRequestAttachment::set_parententityid(const char* value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void RevocationRequestAttachment::set_parententityid(const char* value, size_t size) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RevocationRequestAttachment::mutable_parententityid() {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  return parententityid_;
}
inline ::std::string* RevocationRequestAttachment::release_parententityid() {
  clear_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parententityid_;
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RevocationRequestAttachment::set_allocated_parententityid(::std::string* parententityid) {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    delete parententityid_;
  }
  if (parententityid) {
    set_has_parententityid();
    parententityid_ = parententityid;
  } else {
    clear_has_parententityid();
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
inline bool RevocationRequestAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RevocationRequestAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RevocationRequestAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RevocationRequestAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& RevocationRequestAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* RevocationRequestAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* RevocationRequestAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void RevocationRequestAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// -------------------------------------------------------------------

// XmlSignatureRejectionAttachment

// required string ParentEntityId = 1;
inline bool XmlSignatureRejectionAttachment::has_parententityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmlSignatureRejectionAttachment::set_has_parententityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmlSignatureRejectionAttachment::clear_has_parententityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmlSignatureRejectionAttachment::clear_parententityid() {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    parententityid_->clear();
  }
  clear_has_parententityid();
}
inline const ::std::string& XmlSignatureRejectionAttachment::parententityid() const {
  return *parententityid_;
}
inline void XmlSignatureRejectionAttachment::set_parententityid(const ::std::string& value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void XmlSignatureRejectionAttachment::set_parententityid(const char* value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void XmlSignatureRejectionAttachment::set_parententityid(const char* value, size_t size) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmlSignatureRejectionAttachment::mutable_parententityid() {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  return parententityid_;
}
inline ::std::string* XmlSignatureRejectionAttachment::release_parententityid() {
  clear_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parententityid_;
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmlSignatureRejectionAttachment::set_allocated_parententityid(::std::string* parententityid) {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    delete parententityid_;
  }
  if (parententityid) {
    set_has_parententityid();
    parententityid_ = parententityid;
  } else {
    clear_has_parententityid();
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Diadoc.Api.Proto.Events.SignedContent SignedContent = 2;
inline bool XmlSignatureRejectionAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmlSignatureRejectionAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmlSignatureRejectionAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmlSignatureRejectionAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::Diadoc::Api::Proto::Events::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::Diadoc::Api::Proto::Events::SignedContent& XmlSignatureRejectionAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* XmlSignatureRejectionAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::Diadoc::Api::Proto::Events::SignedContent;
  return signedcontent_;
}
inline ::Diadoc::Api::Proto::Events::SignedContent* XmlSignatureRejectionAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::Diadoc::Api::Proto::Events::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void XmlSignatureRejectionAttachment::set_allocated_signedcontent(::Diadoc::Api::Proto::Events::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Events
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Events_2fDiadocMessage_2ePostApi_2eproto__INCLUDED
