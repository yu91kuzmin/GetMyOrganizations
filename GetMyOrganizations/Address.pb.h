// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Address.proto

#ifndef PROTOBUF_Address_2eproto__INCLUDED
#define PROTOBUF_Address_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Address_2eproto();
void protobuf_AssignDesc_Address_2eproto();
void protobuf_ShutdownFile_Address_2eproto();

class Address;
class RussianAddress;
class ForeignAddress;

// ===================================================================

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Diadoc.Api.Proto.RussianAddress RussianAddress = 1;
  inline bool has_russianaddress() const;
  inline void clear_russianaddress();
  static const int kRussianAddressFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::RussianAddress& russianaddress() const;
  inline ::Diadoc::Api::Proto::RussianAddress* mutable_russianaddress();
  inline ::Diadoc::Api::Proto::RussianAddress* release_russianaddress();
  inline void set_allocated_russianaddress(::Diadoc::Api::Proto::RussianAddress* russianaddress);

  // optional .Diadoc.Api.Proto.ForeignAddress ForeignAddress = 2;
  inline bool has_foreignaddress() const;
  inline void clear_foreignaddress();
  static const int kForeignAddressFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::ForeignAddress& foreignaddress() const;
  inline ::Diadoc::Api::Proto::ForeignAddress* mutable_foreignaddress();
  inline ::Diadoc::Api::Proto::ForeignAddress* release_foreignaddress();
  inline void set_allocated_foreignaddress(::Diadoc::Api::Proto::ForeignAddress* foreignaddress);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Address)
 private:
  inline void set_has_russianaddress();
  inline void clear_has_russianaddress();
  inline void set_has_foreignaddress();
  inline void clear_has_foreignaddress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Diadoc::Api::Proto::RussianAddress* russianaddress_;
  ::Diadoc::Api::Proto::ForeignAddress* foreignaddress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Address_2eproto();
  friend void protobuf_AssignDesc_Address_2eproto();
  friend void protobuf_ShutdownFile_Address_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class RussianAddress : public ::google::protobuf::Message {
 public:
  RussianAddress();
  virtual ~RussianAddress();

  RussianAddress(const RussianAddress& from);

  inline RussianAddress& operator=(const RussianAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RussianAddress& default_instance();

  void Swap(RussianAddress* other);

  // implements Message ----------------------------------------------

  RussianAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RussianAddress& from);
  void MergeFrom(const RussianAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ZipCode = 1;
  inline bool has_zipcode() const;
  inline void clear_zipcode();
  static const int kZipCodeFieldNumber = 1;
  inline const ::std::string& zipcode() const;
  inline void set_zipcode(const ::std::string& value);
  inline void set_zipcode(const char* value);
  inline void set_zipcode(const char* value, size_t size);
  inline ::std::string* mutable_zipcode();
  inline ::std::string* release_zipcode();
  inline void set_allocated_zipcode(::std::string* zipcode);

  // required string Region = 2;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  inline void set_allocated_region(::std::string* region);

  // optional string Territory = 3;
  inline bool has_territory() const;
  inline void clear_territory();
  static const int kTerritoryFieldNumber = 3;
  inline const ::std::string& territory() const;
  inline void set_territory(const ::std::string& value);
  inline void set_territory(const char* value);
  inline void set_territory(const char* value, size_t size);
  inline ::std::string* mutable_territory();
  inline ::std::string* release_territory();
  inline void set_allocated_territory(::std::string* territory);

  // optional string City = 4;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 4;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string Locality = 5;
  inline bool has_locality() const;
  inline void clear_locality();
  static const int kLocalityFieldNumber = 5;
  inline const ::std::string& locality() const;
  inline void set_locality(const ::std::string& value);
  inline void set_locality(const char* value);
  inline void set_locality(const char* value, size_t size);
  inline ::std::string* mutable_locality();
  inline ::std::string* release_locality();
  inline void set_allocated_locality(::std::string* locality);

  // optional string Street = 6;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 6;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string Building = 7;
  inline bool has_building() const;
  inline void clear_building();
  static const int kBuildingFieldNumber = 7;
  inline const ::std::string& building() const;
  inline void set_building(const ::std::string& value);
  inline void set_building(const char* value);
  inline void set_building(const char* value, size_t size);
  inline ::std::string* mutable_building();
  inline ::std::string* release_building();
  inline void set_allocated_building(::std::string* building);

  // optional string Block = 8;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 8;
  inline const ::std::string& block() const;
  inline void set_block(const ::std::string& value);
  inline void set_block(const char* value);
  inline void set_block(const char* value, size_t size);
  inline ::std::string* mutable_block();
  inline ::std::string* release_block();
  inline void set_allocated_block(::std::string* block);

  // optional string Apartment = 9;
  inline bool has_apartment() const;
  inline void clear_apartment();
  static const int kApartmentFieldNumber = 9;
  inline const ::std::string& apartment() const;
  inline void set_apartment(const ::std::string& value);
  inline void set_apartment(const char* value);
  inline void set_apartment(const char* value, size_t size);
  inline ::std::string* mutable_apartment();
  inline ::std::string* release_apartment();
  inline void set_allocated_apartment(::std::string* apartment);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.RussianAddress)
 private:
  inline void set_has_zipcode();
  inline void clear_has_zipcode();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_territory();
  inline void clear_has_territory();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_locality();
  inline void clear_has_locality();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_building();
  inline void clear_has_building();
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_apartment();
  inline void clear_has_apartment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* zipcode_;
  ::std::string* region_;
  ::std::string* territory_;
  ::std::string* city_;
  ::std::string* locality_;
  ::std::string* street_;
  ::std::string* building_;
  ::std::string* block_;
  ::std::string* apartment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Address_2eproto();
  friend void protobuf_AssignDesc_Address_2eproto();
  friend void protobuf_ShutdownFile_Address_2eproto();

  void InitAsDefaultInstance();
  static RussianAddress* default_instance_;
};
// -------------------------------------------------------------------

class ForeignAddress : public ::google::protobuf::Message {
 public:
  ForeignAddress();
  virtual ~ForeignAddress();

  ForeignAddress(const ForeignAddress& from);

  inline ForeignAddress& operator=(const ForeignAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForeignAddress& default_instance();

  void Swap(ForeignAddress* other);

  // implements Message ----------------------------------------------

  ForeignAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForeignAddress& from);
  void MergeFrom(const ForeignAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Country = 1;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 1;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // required string Address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.ForeignAddress)
 private:
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* country_;
  ::std::string* address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Address_2eproto();
  friend void protobuf_AssignDesc_Address_2eproto();
  friend void protobuf_ShutdownFile_Address_2eproto();

  void InitAsDefaultInstance();
  static ForeignAddress* default_instance_;
};
// ===================================================================


// ===================================================================

// Address

// optional .Diadoc.Api.Proto.RussianAddress RussianAddress = 1;
inline bool Address::has_russianaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_russianaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_russianaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_russianaddress() {
  if (russianaddress_ != NULL) russianaddress_->::Diadoc::Api::Proto::RussianAddress::Clear();
  clear_has_russianaddress();
}
inline const ::Diadoc::Api::Proto::RussianAddress& Address::russianaddress() const {
  return russianaddress_ != NULL ? *russianaddress_ : *default_instance_->russianaddress_;
}
inline ::Diadoc::Api::Proto::RussianAddress* Address::mutable_russianaddress() {
  set_has_russianaddress();
  if (russianaddress_ == NULL) russianaddress_ = new ::Diadoc::Api::Proto::RussianAddress;
  return russianaddress_;
}
inline ::Diadoc::Api::Proto::RussianAddress* Address::release_russianaddress() {
  clear_has_russianaddress();
  ::Diadoc::Api::Proto::RussianAddress* temp = russianaddress_;
  russianaddress_ = NULL;
  return temp;
}
inline void Address::set_allocated_russianaddress(::Diadoc::Api::Proto::RussianAddress* russianaddress) {
  delete russianaddress_;
  russianaddress_ = russianaddress;
  if (russianaddress) {
    set_has_russianaddress();
  } else {
    clear_has_russianaddress();
  }
}

// optional .Diadoc.Api.Proto.ForeignAddress ForeignAddress = 2;
inline bool Address::has_foreignaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_foreignaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_foreignaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_foreignaddress() {
  if (foreignaddress_ != NULL) foreignaddress_->::Diadoc::Api::Proto::ForeignAddress::Clear();
  clear_has_foreignaddress();
}
inline const ::Diadoc::Api::Proto::ForeignAddress& Address::foreignaddress() const {
  return foreignaddress_ != NULL ? *foreignaddress_ : *default_instance_->foreignaddress_;
}
inline ::Diadoc::Api::Proto::ForeignAddress* Address::mutable_foreignaddress() {
  set_has_foreignaddress();
  if (foreignaddress_ == NULL) foreignaddress_ = new ::Diadoc::Api::Proto::ForeignAddress;
  return foreignaddress_;
}
inline ::Diadoc::Api::Proto::ForeignAddress* Address::release_foreignaddress() {
  clear_has_foreignaddress();
  ::Diadoc::Api::Proto::ForeignAddress* temp = foreignaddress_;
  foreignaddress_ = NULL;
  return temp;
}
inline void Address::set_allocated_foreignaddress(::Diadoc::Api::Proto::ForeignAddress* foreignaddress) {
  delete foreignaddress_;
  foreignaddress_ = foreignaddress;
  if (foreignaddress) {
    set_has_foreignaddress();
  } else {
    clear_has_foreignaddress();
  }
}

// -------------------------------------------------------------------

// RussianAddress

// optional string ZipCode = 1;
inline bool RussianAddress::has_zipcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RussianAddress::set_has_zipcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RussianAddress::clear_has_zipcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RussianAddress::clear_zipcode() {
  if (zipcode_ != &::google::protobuf::internal::kEmptyString) {
    zipcode_->clear();
  }
  clear_has_zipcode();
}
inline const ::std::string& RussianAddress::zipcode() const {
  return *zipcode_;
}
inline void RussianAddress::set_zipcode(const ::std::string& value) {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  zipcode_->assign(value);
}
inline void RussianAddress::set_zipcode(const char* value) {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  zipcode_->assign(value);
}
inline void RussianAddress::set_zipcode(const char* value, size_t size) {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  zipcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_zipcode() {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  return zipcode_;
}
inline ::std::string* RussianAddress::release_zipcode() {
  clear_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zipcode_;
    zipcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_zipcode(::std::string* zipcode) {
  if (zipcode_ != &::google::protobuf::internal::kEmptyString) {
    delete zipcode_;
  }
  if (zipcode) {
    set_has_zipcode();
    zipcode_ = zipcode;
  } else {
    clear_has_zipcode();
    zipcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Region = 2;
inline bool RussianAddress::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RussianAddress::set_has_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RussianAddress::clear_has_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RussianAddress::clear_region() {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& RussianAddress::region() const {
  return *region_;
}
inline void RussianAddress::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void RussianAddress::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(value);
}
inline void RussianAddress::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    region_ = new ::std::string;
  }
  return region_;
}
inline ::std::string* RussianAddress::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_region(::std::string* region) {
  if (region_ != &::google::protobuf::internal::kEmptyString) {
    delete region_;
  }
  if (region) {
    set_has_region();
    region_ = region;
  } else {
    clear_has_region();
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Territory = 3;
inline bool RussianAddress::has_territory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RussianAddress::set_has_territory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RussianAddress::clear_has_territory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RussianAddress::clear_territory() {
  if (territory_ != &::google::protobuf::internal::kEmptyString) {
    territory_->clear();
  }
  clear_has_territory();
}
inline const ::std::string& RussianAddress::territory() const {
  return *territory_;
}
inline void RussianAddress::set_territory(const ::std::string& value) {
  set_has_territory();
  if (territory_ == &::google::protobuf::internal::kEmptyString) {
    territory_ = new ::std::string;
  }
  territory_->assign(value);
}
inline void RussianAddress::set_territory(const char* value) {
  set_has_territory();
  if (territory_ == &::google::protobuf::internal::kEmptyString) {
    territory_ = new ::std::string;
  }
  territory_->assign(value);
}
inline void RussianAddress::set_territory(const char* value, size_t size) {
  set_has_territory();
  if (territory_ == &::google::protobuf::internal::kEmptyString) {
    territory_ = new ::std::string;
  }
  territory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_territory() {
  set_has_territory();
  if (territory_ == &::google::protobuf::internal::kEmptyString) {
    territory_ = new ::std::string;
  }
  return territory_;
}
inline ::std::string* RussianAddress::release_territory() {
  clear_has_territory();
  if (territory_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = territory_;
    territory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_territory(::std::string* territory) {
  if (territory_ != &::google::protobuf::internal::kEmptyString) {
    delete territory_;
  }
  if (territory) {
    set_has_territory();
    territory_ = territory;
  } else {
    clear_has_territory();
    territory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string City = 4;
inline bool RussianAddress::has_city() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RussianAddress::set_has_city() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RussianAddress::clear_has_city() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RussianAddress::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& RussianAddress::city() const {
  return *city_;
}
inline void RussianAddress::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void RussianAddress::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void RussianAddress::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* RussianAddress::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Locality = 5;
inline bool RussianAddress::has_locality() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RussianAddress::set_has_locality() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RussianAddress::clear_has_locality() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RussianAddress::clear_locality() {
  if (locality_ != &::google::protobuf::internal::kEmptyString) {
    locality_->clear();
  }
  clear_has_locality();
}
inline const ::std::string& RussianAddress::locality() const {
  return *locality_;
}
inline void RussianAddress::set_locality(const ::std::string& value) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(value);
}
inline void RussianAddress::set_locality(const char* value) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(value);
}
inline void RussianAddress::set_locality(const char* value, size_t size) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_locality() {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  return locality_;
}
inline ::std::string* RussianAddress::release_locality() {
  clear_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locality_;
    locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_locality(::std::string* locality) {
  if (locality_ != &::google::protobuf::internal::kEmptyString) {
    delete locality_;
  }
  if (locality) {
    set_has_locality();
    locality_ = locality;
  } else {
    clear_has_locality();
    locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Street = 6;
inline bool RussianAddress::has_street() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RussianAddress::set_has_street() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RussianAddress::clear_has_street() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RussianAddress::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& RussianAddress::street() const {
  return *street_;
}
inline void RussianAddress::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void RussianAddress::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void RussianAddress::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* RussianAddress::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Building = 7;
inline bool RussianAddress::has_building() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RussianAddress::set_has_building() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RussianAddress::clear_has_building() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RussianAddress::clear_building() {
  if (building_ != &::google::protobuf::internal::kEmptyString) {
    building_->clear();
  }
  clear_has_building();
}
inline const ::std::string& RussianAddress::building() const {
  return *building_;
}
inline void RussianAddress::set_building(const ::std::string& value) {
  set_has_building();
  if (building_ == &::google::protobuf::internal::kEmptyString) {
    building_ = new ::std::string;
  }
  building_->assign(value);
}
inline void RussianAddress::set_building(const char* value) {
  set_has_building();
  if (building_ == &::google::protobuf::internal::kEmptyString) {
    building_ = new ::std::string;
  }
  building_->assign(value);
}
inline void RussianAddress::set_building(const char* value, size_t size) {
  set_has_building();
  if (building_ == &::google::protobuf::internal::kEmptyString) {
    building_ = new ::std::string;
  }
  building_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_building() {
  set_has_building();
  if (building_ == &::google::protobuf::internal::kEmptyString) {
    building_ = new ::std::string;
  }
  return building_;
}
inline ::std::string* RussianAddress::release_building() {
  clear_has_building();
  if (building_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = building_;
    building_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_building(::std::string* building) {
  if (building_ != &::google::protobuf::internal::kEmptyString) {
    delete building_;
  }
  if (building) {
    set_has_building();
    building_ = building;
  } else {
    clear_has_building();
    building_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Block = 8;
inline bool RussianAddress::has_block() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RussianAddress::set_has_block() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RussianAddress::clear_has_block() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RussianAddress::clear_block() {
  if (block_ != &::google::protobuf::internal::kEmptyString) {
    block_->clear();
  }
  clear_has_block();
}
inline const ::std::string& RussianAddress::block() const {
  return *block_;
}
inline void RussianAddress::set_block(const ::std::string& value) {
  set_has_block();
  if (block_ == &::google::protobuf::internal::kEmptyString) {
    block_ = new ::std::string;
  }
  block_->assign(value);
}
inline void RussianAddress::set_block(const char* value) {
  set_has_block();
  if (block_ == &::google::protobuf::internal::kEmptyString) {
    block_ = new ::std::string;
  }
  block_->assign(value);
}
inline void RussianAddress::set_block(const char* value, size_t size) {
  set_has_block();
  if (block_ == &::google::protobuf::internal::kEmptyString) {
    block_ = new ::std::string;
  }
  block_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_block() {
  set_has_block();
  if (block_ == &::google::protobuf::internal::kEmptyString) {
    block_ = new ::std::string;
  }
  return block_;
}
inline ::std::string* RussianAddress::release_block() {
  clear_has_block();
  if (block_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = block_;
    block_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_block(::std::string* block) {
  if (block_ != &::google::protobuf::internal::kEmptyString) {
    delete block_;
  }
  if (block) {
    set_has_block();
    block_ = block;
  } else {
    clear_has_block();
    block_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Apartment = 9;
inline bool RussianAddress::has_apartment() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RussianAddress::set_has_apartment() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RussianAddress::clear_has_apartment() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RussianAddress::clear_apartment() {
  if (apartment_ != &::google::protobuf::internal::kEmptyString) {
    apartment_->clear();
  }
  clear_has_apartment();
}
inline const ::std::string& RussianAddress::apartment() const {
  return *apartment_;
}
inline void RussianAddress::set_apartment(const ::std::string& value) {
  set_has_apartment();
  if (apartment_ == &::google::protobuf::internal::kEmptyString) {
    apartment_ = new ::std::string;
  }
  apartment_->assign(value);
}
inline void RussianAddress::set_apartment(const char* value) {
  set_has_apartment();
  if (apartment_ == &::google::protobuf::internal::kEmptyString) {
    apartment_ = new ::std::string;
  }
  apartment_->assign(value);
}
inline void RussianAddress::set_apartment(const char* value, size_t size) {
  set_has_apartment();
  if (apartment_ == &::google::protobuf::internal::kEmptyString) {
    apartment_ = new ::std::string;
  }
  apartment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RussianAddress::mutable_apartment() {
  set_has_apartment();
  if (apartment_ == &::google::protobuf::internal::kEmptyString) {
    apartment_ = new ::std::string;
  }
  return apartment_;
}
inline ::std::string* RussianAddress::release_apartment() {
  clear_has_apartment();
  if (apartment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = apartment_;
    apartment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RussianAddress::set_allocated_apartment(::std::string* apartment) {
  if (apartment_ != &::google::protobuf::internal::kEmptyString) {
    delete apartment_;
  }
  if (apartment) {
    set_has_apartment();
    apartment_ = apartment;
  } else {
    clear_has_apartment();
    apartment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ForeignAddress

// required string Country = 1;
inline bool ForeignAddress::has_country() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForeignAddress::set_has_country() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForeignAddress::clear_has_country() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForeignAddress::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& ForeignAddress::country() const {
  return *country_;
}
inline void ForeignAddress::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void ForeignAddress::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void ForeignAddress::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForeignAddress::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* ForeignAddress::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ForeignAddress::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Address = 2;
inline bool ForeignAddress::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForeignAddress::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForeignAddress::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForeignAddress::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ForeignAddress::address() const {
  return *address_;
}
inline void ForeignAddress::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ForeignAddress::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ForeignAddress::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForeignAddress::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ForeignAddress::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ForeignAddress::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Address_2eproto__INCLUDED
